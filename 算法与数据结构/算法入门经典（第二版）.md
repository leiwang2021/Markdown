# 算法入门经典（第二版）

## 第一章　程序设计入门

## 第三章　数组和字符串

### 3.1 数组

- memcpy(b,a, sizeof(int)*k)   从数组a复制k个元素到数组b, 包含头文件string.h
- memset(a,0 sizeof(a)) 把数组a清零，也在string.h中定义

### 3.2 字符数组

## 第四章 函数和递归

- 调用栈：

  调用栈由栈帧组成，每个栈帧对应着一个未运行完的函数，在gdb中可以用backtrace(bt)命令打印所有栈帧信息

- gdb的调试： gdb a.out           b 加断点   r 运行   q退出 s单步执行  bt查看调用栈

- 如果在递归调用初期查看栈，则每次递归调用都会多出一个栈帧，在函数体执行完毕后删除栈帧，处理返回值并修改当前代码行

- 段错误与栈溢出

  - 编译后的可执行文件，Linux下用的是ELF格式，Windows下用的PE文件格式，但都有一个共同的概念：段（segmentation）
  - 段指二进制文件内的区域，所有某种特定类型信息都被保存在里面，可用size a.out  命令得到可执行文件中各个段的大小。正文段（text)用于储存指令，数据段(data)用于存储已已初始化的全局变量，bss段用于存储未赋值的全局变量所需的空间
  - 调用栈在运行时创建，调用栈所在的段称为堆栈段（Stack Segment) ，堆栈段有自己的大小，不能被越界访问，否则会出现段错误，栈溢出
  - 在运行时，程序会动态创建一个堆栈段，里面放着调用栈，保存着函数的调用关系和局部变量
  - ulimit -a 显示当前栈大小   ulimit -s 32768将把栈大小指定为32MB
  - 局部变量是放在堆栈段的，栈溢出不一定是递归调用太多，也可能是局部变量太大

## 第五章 STL

### 5.1 从C到C++

- C++版框架
  - C语言中大多数头文件在C++中仍可使用，推荐是去掉.h后缀，在C头文件之前加一个小写的c字母
  - C++流输入，缺点是速度慢，可以关闭和stdio的同步，即调用ios::sync_with_stdio(false)
- 引用
  - C++中的引用就是变量的别名，可以在一定程度上代替C中的指针
- 字符串
  - C++在string头文件里定义了string类型，支持流式读写
  - 可以把string作为流进行读写，但string很慢，sstream更慢
- 结构体
  - 在C++中，Struct和class最主要的区别是默认访问权限和继承方式不同，其他方面差异很小
  - C++中的struct除了可以拥有成员变量之外，还可以拥有成员函数
- 模板

### 5.2 STL初步

- 排序与检索

  - sort可对任意对象进行排序，不是内置类型时，需定义小于运算符或传入一个小于函数
  - lower_bound的作用是查找大于或者等于x的第一个位置

- vector

  - .size 读取大小， .resize改变大小， .push_back()向尾部添加函数,  .pop_back()删除最后一个元素
  - 可直接赋值，可作为函数的返回值
  - 可以用clear()清空，empty（）测试是否为空

- 集合set

  - set中元素已从小到大排好序

- 映射: map

  - map和set都支持insert 、find、count和remove操作，并且可以按照从小到大的顺序循环遍历其中的元素，map还提供了[]运算符

- 栈、队列与优先队列

  STL提供了三种数据结构：栈，队列，优先队列

  - 栈：后进先出（LIFO），支持push和pop操作，定义在<stack>中，top()取栈顶元素，但不删除
  - 队列：先进先出（FIFO），定义在头文件<queqe>中，用push和pop操作入队和出队，front()取队首元素，但不删除
  - 优先队列：先出队列的队列中优先级最高的元素，用priority_queue声明，只要元素定义了小于运算符，就可以使用优先队列
  - 重载了()运算符的类叫做仿函数

- 测试STL

  - cstdlib中的rand()可生成闭区间[0,RAND_MAX]内均匀分布的随机整数
  - srand(time(NULL))初始化随机数种子
  - 把vector作为参数或者返回值时，应尽量改成引用方式传递参数，以避免不必要的值被复制
  - assert(表达式)  当表达式为真时无变化，当表达式为假时强行终止程序，并给出错误提示
  - vector的速度接近数组，set和map每次插入、查找和删除时间和元素个数的对数呈线性关系

# 第六章 数据结构基础

线性表：栈、队列、链表

二叉树、图

### 6.1 栈和队列

- 如果要在队列两端进行插入和删除，可以用STL中的双端队列deque
- 栈

### 6.2 链表

- 在数组中频繁移动元素很低效，可以使用链表
- 常在链表的第一个元素之前放一个虚拟节点
- 双向链表

