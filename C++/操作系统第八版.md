# 操作系统第八版

## 第一章　计算机系统概述

### 1.1 基本构成

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-10 21-11-02.png)

### 1.2 微处理器的发展

### 1.3 指令的执行

- PC
- IR

### 1.4 中断

### 1.5 存储器的层次结构

### 1.6 高速缓存

### 1.7 直接内存存取

- 可编程I/O
- 中断驱动I/O
- 直接内存存取(DMA)

### 1.8 多处理器和多核计算机组织结构



## 第二章　操作系统概述

### 2.1 操作系统的目标和功能

- 作为用户/计算机接口的操作系统

  - 提供一些系统程序
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 10-28-53.png)

  - 程序开发
  - 程序运行
  - I/O设备访问
  - 文件访问控制
  - 系统访问
  - 错误检测和响应
  - 记账
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 10-32-45.png)

- 作为资源管理器的操作系统
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 10-55-10.png)

- 操作系统的易扩展性

### 2.2 操作系统的发展史

- 串行处理
- 简单批处理系统
- 多道批处理系统
- 分时系统

### 2.3 主要成就

- 进程

  - 一段可执行的程序、程序所需要的相关数据(变量、工作空间、缓冲区等)、程序执行的上下文
  - 执行上下文又称为进程状态，是操作系统用来管理和控制进程所需的内部数据
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 11-14-41.png)

  - 进程索引寄存器包含当前正在控制处理器的进程在进程表中的索引
  - 基址寄存器、界限寄存器定义该进程所占据的存储器区域
  - 进程可以被当作数据结构来实现
  - 一个分配了资源的进程可以分解为多个并发的线程，这些线程相互协作执行，完成进程的工作

- 内存管理

  - 进程隔离
  - 自动分配和管理
  - 支持模块化程序设计
  - 保护和访问控制
  - 长期存储
  - 虚存和文件系统机制
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 11-30-27.png)

- 信息保护和安全
- 调度和资源管理
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 11-34-28.png)

### 2.4 现代操作系统的特征

- 微内核体系结构
- 多线程: 把执行一个应用程序的进程分为可以同时运行的多个线程
- 对称多处理
- 面向对象设计

### 2.5 容错性

- 操作系统机制
  - 进程隔离
  - 并发控制
  - 虚拟机
  - 检测点和回滚机制

### 2.6 多处理器和多核操作系统设计考虑因素

### 2.7 Windows

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-03-48.png)

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-06-26.png)

- 执行体模块
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-08-29.png)

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-09-51.png)

- 客户－服务器模型
- 线程和SMP
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-13-01.png)

- Windows对象
  - 在用户模式下访问数据时，或在访问共享数据或受限数据时，都要使用对象，对象表示的实体有文件、进程、线程、信号、计时器和窗口
  - 应用程序是通过一组执行体支持的对象操作函数来间接操作对象的
  - 创建对象后，请求这一创建的应用程序会得到该对象的句柄，句柄实际上是指向被引用对象的指针，句柄可被同一个进程中的任何线程使用
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-20-55.png)



### 2.8 传统的UNIX系统

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-25-21.png)

### 2.9 现代UNIX系统

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-27-15.png)

### 2.10 Linux操作系统

- 模块结构

  - Linux是由很多模块组成的，这些模块可以由命令自动加载和卸载，这些相对独立的块称为可加载模块
    - 动态链接
    - 可堆叠模块

- 内核组件

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-36-35.png)

  - 主要内核组件
    - 信号，内核使用信号来向进程提供信息
    - 系统调用，进程通过系统调用来请求系统服务，分为6类: 文件系统，进程，调度，进程间通信，套接字，其他
    - 进程和调度器
    - 虚存
    - 文件系统
    - 字符设备驱动
    - 块设备驱动
    - 网络设备驱动
    - 陷进和错误
    - 物理内存
    - 中断

### 2.10 Android

- Android是为触屏移动设备设计的基于Linux的操作系统
- Android软件体系结构
  - 一个完整的软件栈，而非单个操作系统，某种意义上是一种嵌入式Linux
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-47-54.png)

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-12 13-55-07.png)



## 第三章　进程描述和控制

### 3.1 什么是进程

- 背景
  - 开发操作系统是为了给应用程序提供方便、安全和一统的接口
- 进程和进程控制块
  - 一个正在执行的程序，由一组执行的指令、一个当前的状态和一组相关的系统资源表征的活动单元
  - 进程控制块由操作系统创建和管理，进程控制块是操作系统为支持多进程并提供多重处理技术的关键工具
  - 进程中断时，操作系统会把程序计数器和处理器寄存器(上下文数据)保存到进程控制块中的相应位置，进程状态改为其他值
  - 进程由程序代码和相关数据以及进程控制块组成，单处理器计算机在任何时刻最多只能执行一个进程，而正在运行的进程的状态为运行态
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 10-26-36.png)

### 3.2 进程状态

- 由调度器使处理器切换进程
- 两状态进程模型
  - 操作系统的基本职责是控制进程的执行，包括确定交替执行的方式和给进程分配资源
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 10-34-38.png)

- 进程的创建和终止

  - 操作系统建立用于管理该进程的数据结构，并在内存中给它分配地址空间，这些行为构成了一个新进程的创建过程
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 10-37-52.png)

  - 进程派生，父进程和子进程
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 10-40-17.png)

- 五状态模型

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 10-43-26.png)

  - 新建态: 进程控制块已经创建但还未加载到内存中的新进程，操作系统所需的关于该进程的信息保存在内存中的进程表中，但进程本身还未进入内存
  - 就绪态: 进程做好了准备，只要有机会就开始执行
  - 阻塞/等待态: 进程在某些事件发生前不能执行，如I/O操作完成
  - 运行态
  - 退出态

- 被挂起的进程

  - 交换: 若没有就绪进程，操作系统把被阻塞的进程换出到磁盘中的挂起队列
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 10-58-57.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 10-59-23.png)

  - 使用虚存时，可能会执行只有部分内容在内存中的进程，若访问的进程地址不在内存中，则将进程的相应部分调入内存
  - 挂起进程:不在内存中的进程
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-10-16.png)



### 3.3 进程描述

- 操作系统的控制结构

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-13-34.png)

  - 内存表:
    - 用于跟踪内(实)存和外(虚)存
  - 进程表
    - 内存、I/O和文件是代表进程而被管理的，因此进程表中必须有对这些资源的直接或间接引用

- 进程控制结构

  - 属性集称为进程控制块
  - 程序、数据、栈和属性的集合称为进程映像
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-20-45.png)

  - 在操作系统管理进程时，其进程映像至少应该有一部分位于内存中，而要执行该进程，则必须将整个进程映像载入内存中或至少载入虚存中
  - 进程控制块信息分为三类:
    - 进程标识信息
    - 进程状态信息
    - 进程控制信息
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-28-05.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-31-33.png)



### 3.4 进程控制

- 执行模式

  - 用户模式
  - 系统模式/控制模式/内核模式
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-36-40.png)

  - 程序状态字中通常存在一个指示执行模式的位，处理器通过它可知道在什么模式下执行

- 进程创建

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-42-08.png)

- 进程切换

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-44-04.png)

  - 中断
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 11-46-07.png)

  - 陷阱
  - 系统调用，使用系统调用时会将用户进程置为阻塞态
  - 模式切换
    - 出现中断时，将程序计数器置为中断处理程序的开始地址，从用户模式切换到内核模式，以便中断处理代码包含特权指令。处理器现在取中断程序的第一条指令来服务中断，将已中断进程的上下文保存到已中断程序的进程控制块中。模式切换可以在不改变运行态进程的状态的情况下出现
  - 进程切换
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 12-56-12.png)

### 3.5 操作系统的执行

- 操作系统与普通计算机软件以同样的方式运行，即它也是由处理器执行的一个程序
- 操作系统会频繁地释放控制权，并依赖于处理器来恢复控制权
- 无进程内核
  - 进程这一概念仅适用于用户程序，而操作系统代码则是在特权模式下单独运行的实体
- 在用户进程内运行
  - 在用户进程的上下文中执行所有操作系统软件
  - 在一个进程内，用户程序和操作系统程序都可执行，而在不同用户进程中执行的操作系统程序是相同的
- 基于进程的操作系统
  - 把操作系统作为一组系统进程来实现，主要的内核功能被组织为独立的进程
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 13-09-39.png)

### 3.6 UNIX SVR4进程管理

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 13-12-12.png)

- 进程状态

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 13-14-53.png)

  - 只有在进程准备从内核模式转换到用户模式时才可能发生抢占，进程在内核模式下运行时不会被抢占

- 进程描述

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 13-18-43.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 13-28-31.png)

- 进程控制
  - 由内核系统调用fork()实现
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 13-31-09.png)

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-14 13-33-52.png)

