#  C++(Chapter 7-8)

## 函数
对象、结构和基本类型一样，数组是另一种类型，注意数组应用到函数中时
### 复习函数

- 定义、原型和调用
- C++对于返回值类型的限制：不能是数组，可以是其他任意类型，但可将数组作为结构或对象组成部分返回
- C++自动将传递的值转换为原型中指定的类型
### 函数和数组
- 当且仅当用于函数头或函数原型中，int* arr 和int arr[] 的含义是相同的，都意味着arr是一个int指针

- 传递常规变量时，函数将使用该变量的拷贝，但传递数组时，函数将使用原来的数组

- 将数组地址作为参数可以节省复制整个数组所需的时间和内存，使用原始数组增加了破坏数据的风险

- 通过两个不同的参数传递数组类型和元素数量
    ```
    void fillArray(int arr[],int size);
    ```

- 为防止函数无意中修改数组的内容，可在声明形参时使用关键字const

  ```
  void show_array(const double ar[], int n); //不能修改传递的值
  ```

- 使用数组区间的函数，指定元素区间，传递两个指针

- 将const关键字用于指针
  让指针指向一个常量对象
  将指针本身声明为常量

- C++禁止将const的地址赋给非const指针

  ```
  int sloth=3;
  const int* ps=&sloth;  //一个指向const int的指针
  int* const finger=&sloth； //一个const指针指向int  
  ```

  finger和*ps 是const，而\*finger和ps不是

### 函数和二维数组

- 一个指向由4个int组成的数组的指针：  int (*ar2) [4]

- 4个指向int的指针组成的数组: int *ar2 [4]

- ar2\[r]\[c]==\*(\*ar2+r)+c)

### 函数和C风格字符串
- 函数无法返回一个字符串，但可以返回字符串的地址
### 函数和结构
- 结构将其数据组合成单个实体或数据对象，该实体被视为一个整体
- 函数将使用原始结构的副本，函数也可以返回结构
- 按值传递结构：当结构较小时
- 传递结构的地址而不是整个结构以节省时间和空间，使用指向结构的指针

### 函数和string对象
- 像对待内置类型（如int）一样对待string对象
### 函数与array对象
- 按值将对象传递给函数，函数处理的是原始对象的副本，也可以传递指向对象的指针
### 递归
- 递归方法有时也称为分而治之策略

### 函数指针
- 获取函数的地址：只要使用函数名（后面不跟参数）
- 声明函数指针
   ```
   double pam(int);
   double (*pf)(int);  // pf为函数指针，(*pf)是函数
   ```

- *pf(int)意味着pf()是一个返回指针的函数， （\*pf)(int) 意味着pf是一个指向函数的指针

  

## 函数探幽

### 内联函数

编译器使用相应的函数代码替换函数调用，对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来，内联函数比常规函数的运行时间稍快，但代价是需要占用更多的内存

- 在函数声明前加上Inline,在函数定义前加上inline

- 内联函数不能递归

### 引用变量
- 引用变量的主要用途是用作函数的形参，通过将引用变量作为参数，函数将使用原始数据，而不是副本

  ```
  int rates;
  int & doen=rates; //该引用声明允许将rates和doen互换，它们指向相同的值和内存单元
  ```

- 必须在声明引用变量时进行初始化，不能通过赋值来设置

  ```
  int & rodents=rats;
  int * const pr=&rats;   //rodents和 *pr扮演的角色相同
  ```

- 按引用传递允许被调用的函数能访问调用函数中的变量

- 常量引用

  ```
  double refcube(const double &ra)
  ```

- 左值：可被引用的数据对象
- 对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值
- 应尽可能将引用声明为const
- 右值引用： double && rref=std::sqrt(36);
- 与复制原始结构的拷贝相比，使用引用可节省时间和内存
- 应避免返回指向临时变量的指针和引用
- 常规返回函数值是右值，将返回类型申明为const 引用
- 基类引用可以指向派生类对象，而无需进行强制类型转换
- 使用引用参数的原因
   能修改调用函数中的数据对象
   通过传递引用提高程序的运行速度
   
### 默认参数

- 只有原型指定了默认值，函数定义与没有默认参数时完全相同

### 函数重载

- 函数多态（函数重载）能使用多个同名的函数

- 是特征标，而不是函数类型使得可以对函数进行重载

- 返回类型可以不同，但特征标也必须不同

- 仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载

### 函数模板

- 模板允许以泛型的方式编写程序

- 函数模板允许以任意类型的方式来定义函数

  ```
  template <typename, AnyType>
  void Swap(AnyType &a, AnyType &b)
  {
      AnyType temp;
      temp=a;
      a=b;
      b=temp;
  }
  ```

- 重载的模板

- 显式具体化
  如果有多个原型，则非模板版本优先于显式具体化，显式具体化优先于使用模板

  ```
  void Swap(job &,job &);
  
  template<typename T>
  void Swap(T &, T &);
  
  template<> void Swap<job>(job &, job &)  //显式具体化
  ```

- 编译器为特定类型生成函数定义时，得到的是模板实例

- 显式具体化声明在关键字template后包含<>，而显式实例化没有

- 隐式实例化、显式实例化和显式具体化统称为具体化，它们都表示使用具体类型的函数定义，而不是通用描述

- 关键字decltype: 
   ```
   decltype(x+y) xpy;
   xpy=x+y;   //给decltype提供的参数可以是表达式
   ```

- 后置返回类型

  ```
  template<class T1,class T2>
  auto gt(T1 x, T2 y) ->decltype(x+y)
  {
      ...
      return x+y;
  }
  //decltype在参数声明后面，因此x和y位于作用域内
  ```

- 函数模板自动完成重载函数的过程，只需要使用泛型和具体算法来定义函数，编译器将为程序中使用的特定参数类型生成正确的函数定义

- 重载解析：决定为函数调用使用哪一个函数定义

   重载解析将寻找最匹配的函数，如果只有一个这样的函数，则选择它；如果存在多个这样的函数，但其中只有一个是非模板函数，则选择该函数；如果有多个合适的函数，且都为模板函数，但其中一个函数比其他函数更具体，则选择该函数。如果有多个同样合适的非模板函数或模板函数，但没有一个函数比其他函数更具体，则函数调用将是不确定的，因此是错误的。

