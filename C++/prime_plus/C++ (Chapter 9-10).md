# C++ (Chapter 9-10)

## 内存模型和名称空间

### 单独编译

- 头文件、源代码文件、源代码文件

- 如果文件名包含在尖括号中，则编译器将在存储标准头文件的主机系统的文件系统中查找；如果文件名包含在双引号中，则编译器将首先查找当前的工作目录或源代码目录，没有找到，再在标准位置查找。

- 不要在源代码文件中使用#include来包含其他源代码文件

- 在同一个文件中只能将同一个头文件包含一次

  基于预处理器编译指令#ifndef可以处理这种问题

- 在链接编译模块时，确保所有对象文件或库都是由同一个编译器生成的
### 存储连续性、作用域和链接性
- 自动存储持续性，静态存储持续性，动态存储持续性，线程存储持续性

- 作用域，链接性（是否可以共享）

- 新的定义隐藏以前的定义，自动变量只在包含它们的函数或代码块中可见

- 栈：后进先出，管理自动变量

- 静态存储变量（编译器将分配固定的内存块来存储所有的静态变量）
  外部链接性（在代码块的外面声明它），可在其他文件中访问
  内部链接性（在代码块的外面声明它，并使用static限定符），只能在当前文件中访问
  无链接性（在代码块内声明它），只能在当前函数或代码块中访问

- 静态持续性、外部链接性
  定义：为变量分配存储空间
  声明：不为变量分配存储空间，引用已有的变量。 引用声明使用关键字extern，且不进行初始			化
  作用域解析符:: 放在变量名前面时，该运算符表示使用变量的全局版本

- 静态持续性、内部链接性

  在多文件程序中，可以在一个文件中定义一个外部变量，但使用该变量的其他文件必须使用关键字extern声明它

  可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据

- 静态存储持续性、无链接性
  将static限定符用于在代码块中定义的变量，该变量只在代码块中可用，但它在代码块不处于活动状态时仍然存在

- cv-限定符

  const、volatile

- mutable

  用它指出，即使结构（或类）变量为const,其某个成员也可以被修改

  ```
  struct data
  {
      char name[30];
      mutable int accesses;
  }
  ```

- 在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的

- 在函数或代码块中声明const时，其作用域为代码块

- 函数和链接性

  所有函数的存储持续性都自动为静态的，即在整个程序执行期间都一直存在

  默认情况下，函数的链接性为外部的，即可以在文件间共享

  可使用static关键字将函数的链接性设置为内部的，使之只能在一个文件中使用

  对于每个非内联函数，程序只能包含一个定义，内联函数不受约束

- 存储方案和动态分配

  动态内存由new和delete控制

  - 定位new运算符

    能够指定要使用的位置

### 名称空间

​    允许定义一个可在其中声明标识符的命令区域，减少名称冲突，可使用作用域解析符、using声明和编译来使得名称空间中的标识符可用

- 用户定义的名称空间、全局名称空间
  - using声明将特定的名称添加到它所属的声明区域中  
  - using编译指令使所有的名称都可用
  - 使用using声明比使用using编译指令更安全

### 总结

**在开发程序时使用多个文件：使用头文件来定义用户类型，为操纵用户类型的函数提供函数原型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后，将main()和其他使用这些函数的函数放在第三个文件中**

## 对象和类

### 抽象和类

通常将类定义（接口）放在头文件中，并将实现（类方法的代码）放在源代码文件中

- 访问控制
  - 类对象的程序都可以直接访问公有部分，但只能通过公有成员函数来访问对象的私有成员（数据隐藏）
  - 数据项通常放在私有部分，组成类接口的成员函数放在公有部分，使用私有成员函数处理不属于公有接口的实现细节
  - 类对象的默认访问控制:private
  - c++对结构进行了扩展，使之与类有相同的特性，区别是结构的默认访问是public
- 实现类成员函数
  - 定义成员函数时，使用::来标识函数所属的类
  - 类方法可以访问类的private组件
  - 内联方法，其定义位于类声明中的函数都将自动成为内联函数，也可以在类声明之外定义成员函数，使其成为内联函数，加inline限定符。最好将内联定义放在定义类的头文件中
  - 每个新对象都有自己的存储空间，用于存储其内部变量和类成员，但同一个类的所有对象共享同一组类方法
- 使用类
  - 可使用new为类对象分配存储空间，也可将对象作为参数和返回值，也可直接赋值

### 类的构造函数和析构函数

- 声明和定义构造函数

  - 构造函数没有返回值，但没有被声明为void类型
  - 程序声明对象时，将自动调用构造函数。构造函数原型位于类声明的公有部分
  - 数据成员名中一般加后缀_
  - 显示调用构造函数、隐式调用构造函数

- 默认构造函数

  - 如果没有提供任何构造函数，C++将自动提供默认构造函数。若为类定义了构造函数，则必须为其提供默认构造函数
  - 在设计类时，通常应提供对所有类成员做隐式初始化的默认构造函数
  - 隐式地调用默认构造函数时，不要使用圆括号

- 析构函数

  - 在类名前加上~，析构函数没有返回值和参数

  - 在类对象过期时析构函数将自动被调用，如没有提供析构函数，编译器将隐式地声明一个默认析构函数

  - .h头文件：类声明     .cpp源文件：类定义    .cpp 主函数: main

  - 多加个大括号，以表明在执行完代码块后自动变量才消失，才能看到析构函数的调用

  - 在默认情况下，C++将源对象的每个数据成员的内容复制到目标对象中相应的数据成员

  - 自动变量放在栈中，最后创建的对象将最先被删除，最先创建的对象将最后被删除

  - 如果构造函数使用了new,则必须提供使用delete的析构函数

  - 初始化和赋值：

    ```
    Stock stock2=Stock("asefeaws");   //初始化，不一定创建临时对象，效率更高
    stock1=Stock("sedfe");         //赋值，创建一个临时对象
    ```

- 列表初始化

  - 提供与某个构造函数的参数列表匹配的内容，并用大括号括起

    ```
    Stock hot_tip={"dsfsdfs",100,231};
    Stock jock {"sedfsd"};
    ```

- const成员函数

  - 保证函数不会修改调用对象，将const关键字放在括号的后面

    ```
    void Stock::show()  const
    ```

    **称为const成员函数，只要类方法不修改调用对象，应将其声明为const**

### this 指针

this指针指向用来调用成员函数的对象（this被作为隐藏参数传递给方法）

*this是调用对象的别名

```
const Stock & Stock::topval(const Stock & s) const
{
    if(s.total_val>total_val)
    	return s;
    esle
     	return *this;    //调用对象
}
```

### 对象数组

```
Stock mystuff[4]={
    Stock("asda");
    Stock("asdas");
    Stock("sdfa");
    Stock("asedf");
};
```

初始化对象数组，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中。

### 类作用域

- 作用域为类的常量

  声明类只是描述了对象的形式，并没有创建对象，在创建对象前，将没有用于存储值的空间

- 在类声明中声明的枚举的作用域为整个类，不会创建类数据成员

  ```
  enum {Months=12};
  ```

- 静态类成员

- 作用域内枚举，底层类型为int

### 抽象数据类型

