# C++(Chapter 11-12)

## 使用类

### 运算符重载

- 允许将运算符重载扩展到用户定义的类型，需要使用运算符函数的特殊函数形式

  ```c++
  operatorop (argument-list)
  ```

- 不要返回指向局部变量或临时对象的引用，函数执行完毕后，局部变量和临时对象将消失，引用将指向不存在的数据

- operator+例子

  ```c++
  total=coding.operator+(fixing);  
  total=coding+fixing;  //运算符表示法，左侧的对象是调用对象，右侧的对象是作为参数被传递的
  ```

  ```
  Time Time::operator+(const Time & t) const
  {
      Time sum;
      sum.minutes=minutes+t.minutes;
      return sum;
  }
  ```

- 重载的运算符不必是成员函数，但必须至少有一个操作数是用户定义的类型

  - 不能违反原来运算符的句法规则
  - 不能修改运算符的优先级
  - 不能创建新运算符
  - 下面的运算符只能通过成员函数重载:  =  ()  [] ->

- 操作符重载也可实现为非类的成员函数（即全局函数）

  ```C++
  class person
  {
  public:
      int age;
  };
   
  // 左操作数的类型必须被显式指定
  // 此处指定的类型为person类
  bool operator==(person const& p1 ,person const& p2)
  {
      if (p1.age == p2.age)
      {
          return true;
      }
      else
      {
          return false;
      }
  }
  ```

  

### 友元

友元函数、友元类、友元成员函数

通常让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限

非成员函数不是由对象调用的，它使用的所有值（包括对象）都是显式参数

友元函数：一类特殊的非成员函数可以访问类的私有成员

- 创建友元

  将其原型放在类声明中，并在原型声明前加上关键字friend

  ```c++
  friend Time operator*(double m,const Time& t);//不是成员函数，与成员函数的访问权限相同
  ```

  定义如下：

  ```C++
  Time operator*(double m, const Time & t)
  {
      Time result;
      long totalminutes=t.hours*mult*60+t.minutes*mult;
      result.hours=totalminutes/60;
      return result;
  }
  ```

- 如果要为类重载运算符，并将非类的项作为其第一个操作数，则可以**用友元函数来反转操作数的顺序**

- 重载<<运算符

  ostream类将opeartor<<()函数实现为返回一个指向ostream对象的引用

- 只有在类声明中的原型中才能使用friend关键字，除非函数定义也是原型，否则不能在函数定义中使用该关键字。此外，友元函数不使用类限定符

- 由于不知道在类代码文件中已经包含了哪些文件，因此应该将编写的代码所需的头文件包含进来

### 重载运算符：成员函数还是非成员函数

- 对于成员函数来说，一个操作数通过this指针隐式传递，另一个操作数作为函数参数显示地传递；对于友元版本来说，两个操作数都作为参数来传递

### 类的自动转换和强制类型转换

其他类型到类类型的转换；类类型到其他类型的转换

- 只有接受一个参数的构造函数才能作为转换函数

- 关键字explict可用于关闭这种自动特性，但仍然允许显式强制类型转换

  ```c++
  Stonewt myCat;
  //显式强制类型转换
  myCat=Stonewt(19.6);
  myCat=(Stonewt)19.6;
  ```

- 只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果使用了关键字explict限定了构造函数，则只能用于显式转换，否则可用于隐式转换

  ```C++
  Stonewt incognito=275;
  //显式类型转换和隐式类型转换，将数字转换为对象
  Stonewt incognito(275);
  Stonewt incognito=Stonewt(275);
  ```

- 转换函数：类类型到其他类型的转换

  - 创建转换函数： operator typeName();
  - 转换函数必须是类方法。不能指定返回类型，不能有参数，typeName指出了要转换成的类型
  - 当类定义了两种或更多种的转换时，仍可以用显式强制类型转换来指出要使用哪个转换函数
  - 原则上，最好使用显式转换，而避免隐式转换，加explicit将转换运算符声明为显式的

- 将double与对象相加

  ```C++
  operator+(const Stonewt &, const Stonewt &)
  
  Stonewt operator+(double x);
  friend Stonewt operator+(double x, Stonewt & s);
  ```

  第一种方法依赖于隐式转换，程序更简洁，但每次转换时，都将调用转换构造函数

  第二种方法增加一个显式地匹配类型的函数，程序较长，但运行速度较快

## 类和动态内存分配

最好在程序运行时（而不是编译时）确定使用多少内存等问题

离变量最近的决定了它的类型

```C++
int* & p  //p是一个引用，其引用的变量为int指针，  
```

- 三种存放对象的地方：
  - 堆栈
  - 堆
  - 全局数据区
- 三种访问对象的方式：
  - 变量里
  - 指针
  - 引用

### 动态内存和类

- 类所有对象共享同一个静态成员，不要在类声明中初始化静态成员变量，因为声明描述了如何分配内存，但并不分配内存

- 静态数据成员在类声明中声明，在包含类方法的文件中初始化，初始化时使用作用域运算符指出静态类成员所属的类，但如果是const整数类型或枚举类型，则可以在类声明中初始化

- 删除对象可以释放对象本身占用的内存，但不能自动释放属于对象成员的指针指向的内存

- GRF表明程序试图访问禁止它访问的内存单元

- C++自动提供以下的成员函数：

  - 默认构造函数
  - 默认析构函数
  - 复制构造函数
  - 赋值运算符
  - 地址运算符

- 复制构造函数

  ```C++
  className (const class_naem &)
  ```

  新建一个对象并将其初始化为同类现有对象时，复制构造函数都会被调用

  当函数按值传递对象或函数返回对象时，都将使用复制构造函数，生成临时对象时，也将使用复制构造函数。因此，应该按引用传递对象

  - 默认复制构造函数的功能

    逐个复制非静态成员，浅复制，复制的不是字符串，而是指向字符串的指针，可能会出问题

  - 析构函数在任何对象过期时都将被调用，而不管对象是如何被创建的

  - 复制构造函数应当复制字符串并将副本的地址赋给str成员，而不仅仅是复制字符串地址，这样每个对象都有自己的字符串，调用析构函数时都将释放不同的字符串

  - 如果类中包含了使用new初始化的指针成员，应定义一个复制构造函数，以复制指向的数据，而不是指针

- 赋值运算符

  - 赋值运算符的隐式实现也对成员进行逐个复制，应提供赋值运算符进行深度复制的定义

- ```c++
  char* s="hello"  //，s实际上为const,存在代码段里，常量存在代码段里
  ```

- ```
  int x=3;
  const int & z=x   //z是x的别名，但通过z不能修改x
  ```

- 关键字  nullptr 用于表示空指针

- 如果静态成员函数是在公有部分声明的，则可以使用类名和作用域解析运算符来调用它

  静态成员函数只能使用静态数据成员

### 在构造函数中使用new时应注意的事项

- new和delete应相互对应，如果有多个构造函数，则必须以相同的方式使用new，因为只有一个析构函数，所有构造函数都必须与它兼容
- 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象
- 应定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象
- 逐成员复制将使用成员类型定义的复制构造函数和赋值运算符

### 有关返回对象的说明

- 返回指向const对象的引用

  返回对象将调用复制构造函数，而返回引用则不会

- 如果被返回的对象是被调用函数中的局部变量，应返回对象而不是引用，存在调用复制构造函数来创建被返回的对象的开销

- 如果方法或函数要返回局部对象，则应返回对象，而不是指向对象的引用，这种情况下，将使用复制构造函数来生成返回的对象。如果方法或函数要返回一个没有公有复制构造函数的类的对象，它必须返回一个指向这种对象的引用。

### 使用指向对象的指针

- 指针和对象小结

  - 可以使用new来初始化指针，这将创建一个新的对象

    ```C++
    String * favorite=new String(saying[choice])
    ```

  - 可以使用->运算符通过指针访问类方法

- 定位new运算符让你能够在分配内存时能指定内存位置

- 成员初始化列表

  ```C++
  Classy::Classy(int n,int m): mem1(n),mem2(0),mem3(n*m+2)
  //只能用于构造函数，必须用这种格式来初始化引用数据成员
  ```

- 类内初始化

  注意：使用成员初始化列表的构造函数将覆盖相应的类内初始化

## 

## 类继承

### 一个简单的基类

- 原始类称为基类，继承类称为派生类

- 公有派生： class ReatedPlayer : public TableTennisPlayer

  公有基类，公有派生。派生类对象包含基类对象，基类的公有成员成为派生类的公有成员，基类的私有部分也成为派生类的一部分，但只能同基类的公有和保护方法访问

- 派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问

- 创建派生类对象时，程序首先创建基类对象

  ```C++
  RatedPlayer::RatedPlayer(unsiged int r,const string & fn,const string & ln,bool ht):TableTennisPlayer(fn,ln,ht)  //TableTennisPlayer(fn,ln,ht)为成员初始//化列表
  ```

- 必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数

  ```C++
  RatedPlayer::RatedPlayer(unsiged int r,const string & fn,const string & ln,bool ht)
  //与下面的代码等效
  RatedPlayer::RatedPlayer(unsiged int r,const string & fn,const string & ln,bool ht):TableTennisPlayer()
  ```

- 释放对象的顺序与创建对象的顺序相反，首先执行派生类的析构函数，然后调用基类的析构函数

- 除虚基类外，类只能将值传递回相邻的基类

- 派生类可以使用基类的方法，方法不是私有的

- 基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。但是基类指针或引用只能调用基类方法，不能调用派生类方法

- 不可以将基类对象和地址赋给派生类引用和指针

- 基类引用或指针的形参，可以指向基类对象或派生类对象

  ```C++
  RatedPlayer olaf1(1840,'Olaf','Loaf',true);  //派生类对象
  TableTennisPlayer olaf2(olaf1); //将使用隐式复制构造函数，形参是基类引用
  
  TableTennisPlayer winner;
  winner=olaf1;  //将使用隐式重载赋值运算符
  ```

### 继承：is-a 关系

公有继承、保护继承、私有继承

- 公有继承是is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行

### 多态公有继承

- 在派生类中重新定义基类方法
- 使用虚方法
- 如果方法是通过引用或指针而不是对象调用的，virtual将确定使用哪一种方法。如果没有使用virtual，程序将根据引用或指针类型选择方法，如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法
- 经常在基类中将派生类会重新定义的方法申明为虚方法，关键字virtual只用于类声明的方法原型中，而没有应用于方法定义中
- 在派生类中，使用作用域解析符来调用基类方法，派生类不能直接访问基类的私有数据，而必须使用基类的公有方法才能访问这些数据
- 可以使用一个数组来表示多种类型的对象，这就是多态性
- 基类应包含一个虚析构函数，如果析构函数是虚的，将调用相应对象类型的析构函数

### 静态联编和动态联编

- 将源代码中的函数调用解析为执行特定的函数代码块称为函数名联编
- 在编译过程中进行的联编称为静态联编
- 由于虚函数的存在，编译器不知道用户将选择哪种类型的对象，编译器必须生成在程序运行时选择正确的虚方法的代码，称为动态联编
- 将派生类引用或指针转换为基类引用或指针被称为向上强制转换，可以是隐式的
- 将基类指针或引用转换为派生类指针或引用称为向下强制转换，必须使用显式类型转换
- 对于使用基类引用或指针作为参数的函数调用，将进行向上转换
- 编译器对非虚方法使用静态联编，对虚方法使用动态联编，静态联编的效率更高
- 虚函数工作原理：
  - 给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这种数组称为虚函数表（vtbl)
  - 使用虚函数时，每个对象都将增大，增大量为存储地址的空间，对于每个类。编译器都将创建一个虚函数地址表，对于每个函数调用，需要到表中查找地址
- 构造函数不能是虚函数，派生类不继承基类的构造函数，将使用基类的一个构造函数
- 析构函数应当是虚函数，除非类不用做基类
- 友元函数不能是虚函数，因为友元不是类成员
- 如果重新定义派生类中的函数，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可修改为指向派生类的引用或指针，这种例外只适用于返回值，而不适合参数

### 访问控制：protected

private和protected之间的去呗只有在基类派生的类中才会表现出来

- 对于外部世界来说，保护成员的行为与私有成员相似；但对于派生类来说，保护成员的行为与公有成员相似
- 最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据
- 对于成员函数来说，保护访问控制能让派生类访问公众不能使用的内部函数

### 抽象基类（ABC)

- C++使用纯虚函数提供未实现的函数，纯虚函数声明的结尾处为=0

  ```C++
  virtual double Area() const=0; //一个纯虚函数
  ```

- 当类声明中包含纯虚函数时，则不能创建该类的对象。包含纯虚函数的类只能用作基类，要成为真正的ABC，则必须包含一个纯虚函数

- 在原型中使用=0指出类是一个抽象基类，在类中可以不定义该函数

### 继承和动态内存分配

- 成员复制将根据数据类型采用相应的复制方式
- 复制类成员或继承的类组件时，则是使用该类的复制构造函数完成
- 在派生类使用了new时，应为派生类定义显式析构函数，复制构造函数和赋值运算符
- 总之，当基类和派生类都采用动态内存分配时，派生类的析构函数。复制构造函数、赋值运算符都必须使用相应的基类方法来处理基类元素。对于析构函数，这是自动完成的，对于构造函数，这是通过在初始化成员列表中调用基类的复制构造函数来完成的；对于赋值运算符，这是通过使用作用域解析符显示地调用基类的赋值运算符来完成的。
- 派生类如何使用基类的友元，可以通过强制类型转换将派生类引用或指针转换为基类引用或指针，然后使用转换后的指针或引用来调用基类的友元函数

