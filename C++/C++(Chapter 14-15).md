# C++(Chapter 14-15)

## C++中的代码重用

- 本身是另一个类的对象，包含
- 使用私有或保护继承

### 包含对象成员的类

- valarray模板类，由头文件valarray支持，用于处理数值
- 使用公有继承时，类可以继承接口，可能还有实现。不继承接口是has-a关系的组成部分
- 使用explicit防止单参数构造函数的隐式转换，初始化的顺序为它们被声明的顺序

### 私有继承

- 实现has-a关系，基类的公有成员和保护成员都将成为派生类的私有成员

- 提供特性：获得实现，但不获得接口

- 使用多个基类的继承被称为多重继承（MI）

- 对于继承类，构造函数将使用成员初始化列表语法，它使用类名而不是成员名来标识构造函数

- 使用私有继承时将使用类名和作用域解析运算来调用方法

- 访问基类对象：使用强制类型转换

- 在私有继承中，未进行显式类型转换的派生类引用或指针，无法赋值给基类的引用或指针

- 大多数时候使用包含。私有继承提供的特性更多，使用私有继承在需要重新定义虚函数时，或在需要新类访问原有类的保护成员时

- 基类指针或引用不能隐式向上转换

- 保护继承：

  - 在列出基类时使用关键字protected
  - 使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员
  - 只能在派生类中，隐式向上转换

- 使用using声明可重新定义访问权限

  ```C++
  class Student :priavte std::string, private std::valarray<double>
  {
      public:
      using std::valarray<double>::min;
      using std::valarray<double>::max;
  }
  //此声明使得基类的方法可用，就像它们是Student的公有方法一样
  ```

- using声明只适用于继承，不适合于保护

### 多重继承

- 公有MI表示的是is-a关系

- 虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象，关键字virtual

- C++在基类是虚的时候，禁止信息通过中间类自动传递给基类，需要显式地调用基类的构造函数，若不使用，则使用默认构造函数

  ```C++
  SingingWaiter(const Worker & wk, int p=0, int v=Singer::other)
         :Worker(wk), Waiter(wk,p),Singer(wk,v){}
  ```

- 使用哪个方法：**采用作用域解析符**来澄清

- 派生类中的名称优于直接或间接祖先类中的相同名称

- 如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径分别继承非虚基类的一个实例

### 类模板

模板提供参数化类型，能够将类型名作为参数传递给接收方来建立类或函数

- ```C++
  template<class Type> 
  template<typename Type>
  ```

- 如果在类声明中定义了方法（内联），则可以省略模板前缀和类限定符

- 模板必须与特定的模板实例化请求一起使用，将所有模板信息放在头文件中，并在使用模板时包含该头文件

- 非类型参数

  ```C++
  template<class T,int n> //T为类型参数，n为非类型或表达式参数
  ```

- 表达式参数：可以是整型，枚举，引用或指针。模板不能修改参数的值，不能使用参数的地址，实例化模板时，用作表达式参数的值必须是常量表达式

- 构造函数方法使用的是new和delete管理的堆内存，而表达式参数方法使用的是为自动变量维护的内存栈，执行速度更快

- 模板多功能性

  - 模板类可用作基类，组件类，类型参数

  - 可以递归使用模板 

    ```C++
    ArrayTP<ArrayTP<int,5>,10> twodee;
    ```

  - 模板可以包含多个类型参数

    ```C++
    template<class T1,class T2>;
    ```

  - 可以为类模板类型参数提供默认值，不能为函数模板参数提供默认值，可以为非类型参数提供默认值

- 模板的具体化

  - 隐式实例化

    声明一个或多个对象，指出所需的类型

    ```C++
    ArrayTP<int, 100> stuff;
    ```

  - 显式实例化

    声明一个类

    ```C++
    template class ArrayTP<string,100>;
    ```

  - 显式具体化

    采用为具体类型定义的模板，当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化模板

    ```C++
    template<> class Classname<specialized-type-name> {...}；
    template<> class SortedArray<const char char*>
    SortedArray<int> scores;  //采用通用模板
    SortedArray<const char*>  //采用具体化模板
    ```

  - 部分具体化

    部分限制模板的通用性

    ```C++
    template<class T1> class Pair<T1,int> {..}; 
    //template后面的<>声明的没有具体化的类型参数
    ```

  - 如果有多个模板可供选择，编译器将使用具体化程度最高的模板

- 成员模板

  模板可用作结构、类或模板类的成员 

- 将模板用作参数

  ```C++
  template<template <typename T> class Thing>
  class Crab
  //template <typename T> class是类型，Thing是参数
  ```

- 模板类和友元

  - 非模板友元

    ```C++
    friend void reports(HasFriend<T> &);
    ```

  - 模板类的约束模板友元函数

    在类定义的前面声明每个模板函数，在函数中再次将模板声明为友元，为友元提供模板定义

  - 模板类的非约束模板友元函数

    在类内部声明模板，可以创建非约束友元函数，即每个函数具体化都是每个类具体化的友元

- 模板别名

  ```C++
  template<typename T>
  	using arrtype=std::array<T,12>  
  //arrtype<T> 表示类型std::array<T,12>
  ```

- using=用于非模板，与常规typedef等价

  ```
  typedef const char * pc1;
  using pc2=const char*;
  typedef const int *(*pa1)[10];
  using pa2=const int *(*)[10]
  ```




## 友元、异常和其他

### 友元

- 友元类的所有方法都可以访问原始类的私有成员和保护成员
- 友元声明可以位于公有。私有或保护部分，其所在的位置无关紧要
- 友元类是一种自然用语，用于表示一些关系，如：同一个遥控器可用于多台电视机
- 可以选择仅让特定的类成员成为另一个类的友元，而不必让整个类成为友元，必须小心排列各种声明和定义的顺序，使用前向声明
- 通过在方法定义中使用inline关键字，可使其成为内联方法

### 嵌套类

- 嵌套类定义了一种类型，该类型仅在包含嵌套类声明的类中有效
- 如果嵌套类是在另一个类的私有部分声明的，则只有后者知道它
- 如果嵌套类是在另一个类的公有部分声明的，则允许后者、派生类和外部世界使用它，但必须使用类限定符

### 异常

- throw关键字表示引发异常，紧随其后的值指出了异常的特征
- catch关键字表示捕获异常
- try块标识其中特定的异常可能被激活的代码块
- 如果try块中的某条语句导致异常被引发，则后面的catch块将对异常进行处理
- throw语句类似执行返回语句，导致程序沿函数调用序列后退，直到找到包含try块的函数
- 如果函数引发了异常，而没有try块或没有匹配的异常处理程序时，默认情况下，程序最终将调用abort（）函数
- 将对象用作异常类型
- 使用关键字noexcept指出函数不会引发异常
- 假设函数由于出现异常而终止，则程序将释放栈中的内存，但不会释放栈的第一个返回地址后停止，而是继续释放栈，直到找到一个位于try块中的返回地址，随后，控制权将转到块尾的异常处理程序，而不是函数调用后面的第一条语句，称为栈解退
- 程序进行栈解退以退回到能够捕获异常的地方时，将释放栈中的自动存储型变量，如果变量是类对象，将为该对象调用析构函数
- exception头文件定义了exception类，C++可以把它用作其他异常类的基类

### RTTI

运行阶段类型识别

- dynamic_cast 将使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回0
- typeid运算符返回一个指出对象的类型的值,返回一个type_info对象

- type_info 结构存储了有关特定类型的信息

- 只能将RTTI用于包含虚函数的类层次结构

- ```C++
  Superb * pm=dynamic_cast<Superb *>(pg)  //指针pg的类型是否可被安全地转换为Superb *,
  //如果可以，运算符将返回对象的地址，否则将返回一个空指针
  ```

- type_info类的实现随厂商而异，但包含一个name（）成员，该函数返回一个随实现而异的字符串，通常是类的名称

- 如果发现在扩展的if else语句系列中使用了typeid，则应考虑是否应该使用虚函数和dynamic_cast

### 类型转换运算符

- dynamic_cast
- const_cast
- static_cast
- reinterpret_cast



