# CSAPP

## 第一章　计算机系统漫游

### 1.1 信息就是位+上下文

- 源程序是由值0和1组成的位序列，字节序列
- 只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件

### 1.2 程序被其他程序翻译成不同的格式

- gcc -o hello  hello.c
- 编译系统
  - 预处理器(cpp) 读取系统头文件插入到程序文本中，得到修改了的源程序 hello.i

  - 编译器(ccl)将文本文件hello.i 翻译成hello.s  包含一个汇编语言程序,包含函数main的定义

  - 汇编器(as)将hello.s翻译成机器语言指令，得到可重定位目标程序的二进制文件hello.o

  - 链接器(ld)合并hello.o和printf函数的printf.o目标文件，得到可执行目标文件hello,可被加载到内存中，由系统执行

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-04-24.png)

### 1.3 编译系统

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞，缓冲区溢出错误是造成大多数网络安全漏洞的主要原因

### 1.4 处理器读取并解释存储在内存中的指令

- 系统的硬件组成
  - 总线：总线被设计成传送定长的字节块
  - I/O设备
  - 主存，临时存储设备，用于存放程序和程序处理的数据，DRAM
  - 处理器，执行存储在主存中指令的引擎
- 运行hello程序
  - 代码和数据从磁盘复制到主存，再从主存复制到寄存器，再从寄存器文件中复制到显示设备

### 1.5　高速缓存

- 高速缓存存储器存放经常访问的数据，提高访问速度　　SRAM

- 在处理器和主存之间插入一个高速缓存可以提高速度

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-05-12.png)

### 1.6 存储设备层次结构

- 上一层的存储器作为低一层存储器的高速缓存

- 可以利用对整个存储器层次结构的理解提高程序性能

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-05-36.png)

### 1.7 操作系统管理软件

- 所有应用程序对硬件的操作尝试都必须通过操作系统

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-06-02.png)

- 操作系统两个基本功能
  - 防止硬件被失控的应用程序滥用
  - 向应用程序提供简单一致的机制来控制复杂的硬件设备

- 操作系统通过基本的抽象概念(进程、虚拟内存和文件)实现
  - 文件是对I/O设备的抽象表示
  - 虚拟内存是对主存和磁盘I/O设备的抽象表示
  - 进程是对处理器、主存和I/O设备的抽象表示

- 进程

  - 进程是操作系统对一个正在运行的程序的一种抽象
  - 并发运行: 一个进程的指令和另一个进程的指令是交错执行的
  - 上下文:跟踪进程运行所需的所有状态信息
  - 上下文切换: 切换进程
  - 从一个进程到另一个进程的转换是操作系统内核管理的，内核是操作系统代码常驻主存的部分，内核是系统管理全部进程所用代码和数据结构的集合

- 线程

  - 一个进程实际上可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据

- 虚拟内存

  - 为每个进程提供一个假象，即每个进程都独占地使用主存

  - 每个进程看到的内存都是一样的，称为虚拟地址空间

  - 程序代码和数据

  - 堆: 在运行时可动态扩展和收缩

  - 共享库: 存放像C标准库的代码和数据

  - 栈: 编译器用它来实现函数调用

  - 基本思想是把一个进程虚拟内存的内容存储在磁盘上，用主存作为磁盘的高速缓存

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-00-57.png)

- 文件
  - 文件就是字节序列，每个I/O设备都可看成文件
  - 系统中的所有输入输出都是通过Unix I/O的系统函数调用读写文件来实现的

### 1.8 系统之间利用网络通信

- 系统从主存复制一串字节到网络适配器，数据流过网络到达另一台机器

### 1.9

- Amdahl定律，想要显著加速整个系统，必须提升全系统中相当大的部分的速度

- 并发: 一个同时具有多个活动的系统

- 并行: 用并发来使一个系统运行得更快

- 线程级并发

  - 多处理器系统

  - 超线程: 同时多线程，允许一个CPU执行多个控制流的技术

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-22-44.png)

- 指令级并发

  - 同时执行多条指令
  - 若处理器可以达到比一个周期一条指令更快的执行速率，就称为超标量处理器

- 单指令、多数据并发

  - 一条指令可以产生多个可以并行执行的操作

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-35-39.png)

## 第2章　信息的表示和处理

### 2.1 信息存储

- 大多数计算机使用8位的块，即字节作为最小的可寻址的内存单元
- 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存，内存的每一个字节都由一个唯一数字标识，称为地址，地址的集合称为虚拟地址空间
- 字长: 指明指针数据的标称大小，决定虚拟地址空间的最大大小，64位机器可以运行32位机器编译的程序
- 32位程序和64位程序，区别在于程序是如何编译的，而不是其运行的机器类型
- 指针在Win32下的大小为4字节，x64下的大小为8字节
- 寻址和字节顺序
  - 多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址
  - 字节顺序: 从高位地址还是从低位地址存储
  - 小端法和大端法，与机器有关，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则
  - sizeof(T) 返回存在一个类型为T的对象所需要的字节数
  - man ascii可得到一张ASCII字符码的表
- Unicode标准
  - UTF-8表示将每个字符编码为一个字节序列
  - 所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的
- 表示代码
  - 即使完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的，二进制代码很少能在不同的机器和操作系统组合之间移植
  - 程序仅仅只是字节序列
- 布尔代数:  用位向量对集合进行编码
- 逻辑运算和位运算
  - &&       &
  - ||        |
- 移位运算
  - 逻辑右移：左端补k个0
  - 算术右移: 左端补k个最高有效位的值
  - 对于有符号数，默认使用算术右移，对于无符号数，逻辑右移

### 2.2 整数表示

- 无符号数的编码
- 补码编码表示有符号整数
  - 最高有效位为符号位
  - 最小值为10000000000...
  - 最大值为01111111111...
- 有符号数和无符号数之间的转换
  - 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式
- C语言中的有符号数和无符号数
  - 一个有符号数和无符号数运算，隐式地将有符号数强制转换为无符号数
- 扩展一个数字的位表示
- 截断数字
- 有符号数到无符号数的隐式类型转换可能会导致程序错误

### 2.3 整数运算

- 无符号加法
  - 可能会溢出
- 补码加法
- 补码的非
- 无符号乘法
- 补码乘法
- 乘以常数
- 除以2的幂

### 2.4 浮点数

- 二进制小数
- IEEE浮点表示
  - 符号
  - 尾数
  - 阶码
- 舍入
- 浮点运算

### 2.5 总结

- 64位程序的优势是可以突破32位程序具有的4GB地址限制
- 大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码
- 使用位级运算和算术运算组合的方法



## 第三章　程序的机器级表示

- 历史观点

  - 8086　第一代单芯片、16位微处理器之一

  - Intel处理器系列，即x86
  - IA32, Intel 32位体系结构
  - x86-64 Intel64位体系结构

### 3.2 程序编码

  - linux  gcc  -Og -o p p1.c p2.c

  - gcc指GCC C编译器，是Linux上默认的编译器，编译选项 -Og生成符合原始C代码整体结构的机器代码的优化等级。

  - 首先，C预处理器扩展源代码，插入头文件代码，扩展宏；其次，编译器产生两个源文件的汇编代码，分别为p1.s和p2.s；接下来，汇编器将汇编代码转成二进制目标代码文件p1.o p2.o，目标代码是机器代码的一种形式，包含所有指令的二进制表示。最后，链接器将两个目标代码文件与实现库函数的代码合并，并产生最终的可执行代码文件p(由命令行选项-o p指定)

  - 机器级代码

    - 指令体系结构或指令集架构(ISA)定义机器级程序的格式和行为

    - 程序内存包括:  程序的可执行机器代码、操作系统需要的一些信息、用来管理过程调用、返回的运行时栈、用户分配的内存块

    - -S选项可看到C编译器产生的汇编代码　　gcc -Og -S  p1.c　　生成p1.s

    - gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
      后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。
      编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。

    - -c命令行选项，GCC会编译并汇编该代码  生成p1.o 二进制格式

    - 如何展示程序的字节表示: 

      - 用反汇编器确定代码长度为14
      - 运行GNU调试工具GDB     在文件mstore.o上运行GDB,然后  输入命令　(gdb) x/14xb multstore

    - 反汇编器

      - objdump  -d  mstore.o 
      - x86-64的指令长度从1到15个字节不等
      - 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码
      - 后缀q是是大小指示符

    - 生成实际可执行代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数　　-o生成可执行文件

      - gcc -Og -o prog main.c mstore.c

      - 链接器的任务之一是为函数调用找到匹配的函数的可执行代码的位置
      - 最后可能会插入字节，使得能更好地存放下一个代码块

- 格式的注解

  - 以.开头的行都是指导汇编器和链接器工作的伪指令
  - 在C语言中插入汇编代码的方法
    - 用汇编代码编写整个函数，在链接阶段把它们和C函数组合起来
    - 或者利用GCC的支持，直接在C程序中嵌入汇编代码

### 3.3 数据格式

- 大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小

### 3.4 访问信息

- 一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-09 15-17-55.png)

- 生成1字节和2字节数字的指令会保持剩下的字节不变，生成4字节数字的指令会把高位4个字节设置为0
- 操作数指示符
  - 操作数:  立即数(常数)　　寄存器值　　内存的值
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-09 15-30-37.png)
- 数据传送指令
  - MOV类，把数据从源位置复制到目的位置
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-09 15-36-10.png)

- 实例

  - 函数被调用点的指令ret
- 压入和弹出栈数据
  - 在x86-64中，程序栈存放在内存中某个区域
  - push  pop

### 3.5 算术和逻辑操作

- 加载有效地址
  - leaq
- 一元和二元操作
- 移位操作
- 特殊的算术运算

### 3.6 控制

- 条件码
  - CPU维护着一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令
- 访问条件码
- 跳转指令
- 用条件控制实现条件分支
- 用条件传送来实现条件分支
- 循环
  - 可以用条件测试和跳转组合起来实现循环的效果
- swith语句

### 3.7 过程

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-21-22.png)

- 运行时栈
  - 栈和程序寄存器存放着传递控制和数据、分配内存所需的信息
  - x86-64的栈向低地址方向增长，栈指针%rsp指向栈顶元素
  - 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的栈帧
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-25-37.png)
- 转移控制
  - call和ret
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-35-07.png)

- 数据传送
  - 通过寄存器最多传递6个整型参数，如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递
  - 过程Q可以通过寄存器访问参数，有必要的话也可以通过栈访问
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-53-00.png)
- 栈上的局部存储
  - 一般来说，过程通过减小栈指针在栈上分配空间，分配的结果作为栈帧的一部分，标号为局部变量
  - 局部数据必须放在内存中的情况
    - 寄存器不足
    - 对一个局部变量使用地址运算符&
    - 某些局部变量是数组或结构
- 寄存器中的局部存储空间
  - 过程Q保存一个寄存器的值不变，要么是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值
  - 为什么不把所有的局部值都存储在被调用者保存寄存器中？在存储完6个局部变量之后，用完了所有的被调用者保存寄存器，所以剩下的两个值保存在栈上
- 递归过程
  - 递归调用一个函数本身与调用其他函数是一样的，每次函数调用都有它自己的私有状态信息(保存的返回位置和被调用者保存寄存器的值)存储空间
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 20-21-34.png)



### 3.8 数组分配和访问

- 在机器代码中，指针会被翻译成地址计算
- 指针运算
- 嵌套的数组
  - 数组元素在内存中按照行优先的顺序排列
- 定长数组
- 变长数组

### 3.9 异质的数据结构

- 结构

  - 结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址
  - 为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移

- 联合

  - 可以用来访问不同数据类型的位模式

- 数据对齐

  - 许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K的倍数，简化了形成处理器和内存系统之间接口的硬件设计
  - **对齐原则是任何K字节的基本对象的地址必须是K的倍数**
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-11 15-43-53.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-11 15-44-26.png)

  - 编译器会为结构S2分配12个字节，最后3个字节是浪费的空间

  - 任何针对x86-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存，都必须满足16字节对齐

    - 任何内存分配函数生成的块的起始地址都必须是16的倍数
    - 大多数栈帧的边界都必须是16字节的倍数

  - **中间的插入填充和末尾的插入填充**　　　**按偏移量来计算填充的字节,偏移后满足对齐原则**

  - ```c++
    class Test{
         public:
             virtual int test(int m){return m;}
         private:
             int a;
            char b;
             char* c;
     };
     
     struct p1{
         int i;
         char* j;
         char m;
     };
     
     int main()
     {
         Test A;
         cout<<sizeof(A)<<endl;  //填充后为24字节,按偏移量计算填充
         p1 p;
         cout<<sizeof(p)<<endl;  //填充后为24字节，按偏移量计算填充
     }
    
    ```


### 3.10 在机器级程序中将控制与数据结合起来

- 理解指针

  - void* 类型代表通用指针，malloc返回一个通用指针

  - 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值

  - 函数指针:  函数指针的值是该函数机器代码表示中第一条指令的地址　　int  (*fp) (int,int\* )    fp为函数指针

  - ```c++
    int  (*fp) (int,int* )   // fp为函数指针  ()是必须的
    int *f(int *) //f是一个函数
    ```

  

- 使用GDB调试器
  - gdb prog 调试prog程序
  - quit run   kill
  - break   delete
  - stepi    nexti   continue  finish
  - disas
  - info frame
  - info registers
  - help
  - DDD,GDB的扩展，提供了图形界面

- 内存越界引用和缓冲区溢出

- 对抗缓冲区溢出攻击
  - 栈随机化
  - 栈破坏检测
  - 限制可执行代码区域

- 支持变长栈帧



## 第七章　链接

- 链接是将各种代码和数据片段收集并组合成为一个单一文件的过程
- 理解链接器将帮助你构造大型程序
- 理解链接器将帮助你避免一些危险的编程错误
- 理解链接器将帮助你理解语言的作用域规则是如何实现的
- 理解链接将帮助你理解其他重要的系统概念
- 理解链接将使你能利用共享库
- 从传统静态链接到加载时的共享库的动态链接以及运行时的共享库的动态链接

### 7.1 编译器驱动程序

- 预处理器cpp
- 编译器cc1
- 汇编器as
- 链接器ld
- shell调用操作系统中一个叫做loader的函数，它将可执行文件的代码和数据复制到内存，然后将控制转移到这个程序的开头

### 7.2 静态链接

- 以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出

### 7.3 目标文件

- 可重定位目标文件
- 可执行目标文件
- 共享目标文件，可以在加载和运行时被动态地加载进内存并链接
- 各个系统的目标文件格式都不相同，x86-64 Linux和Unix系统使用可执行可链接格式(ELF)

### 7.4 可重定位目标文件

- ELF可重定位目标文件的格式
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-08 14-00-33.png)

### 7.5 符号和符号表

- 三种不同的符号
  - 由模块m定义并能被其他模块引用的全局符号，即非静态的C函数和全局变量
  - 由其他模块定义并被模块m引用的全局符号
  - 只被模块m定义和引用的局部符号，对应于带static属性的C函数和全局变量
- 符号表是由汇编器构造的，使用编译器输出到汇编语言.s文件中的符号
- 对应于本地非静态程序变量的任何符号，在运行时在栈中被管理
- 每个符号都被分配到目标文件的某个节
- 在C中，源文件扮演模块的角色，任何带有static属性声明的全局变量或者函数都是模块私有的，类似地，任何不带static属性声明的全局变量和函数都是公共的，可以被其他模块访问
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-08 14-26-09.png)

- extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。



### 7.6 符号解析

- 静态局部变量也会有本地链接器符号，编译器要确保它们拥有唯一的名字

- 对全局符号的引用很棘手

- 编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字，这种编码过程叫做重整(mangling)

- 链接器如何解析多重定义的全局符号

  - 函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号
  - 规则
    - 不允许有多个同名的强符号
    - 如果有一个强符号和多个弱符号同名，那么选择强符号
    - 如果有多个弱符号同名，任意选择一个
  - 规则2和规则3的应用会造成一些不易察觉的运行时错误

- 与静态库链接

  - 所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库，可用作链接器的输入
  - 在链接时，链接器将只复制被程序引用的目标模块
  - 在Linux系统中，静态库以一种称为存档的特殊文件格式存放在磁盘中，存档文件是一组连接起来的可重定位目标文件的集合，存档文件名由后缀.a标识
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-08 15-54-43.png)

  - 创建函数的静态库
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-08 15-55-30.png)

- 链接器如何使用静态库来解析引用

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-08 15-58-46.png)

- 注意命令行上的库和目标文件的顺序非常重要，注意依赖关系



### 7.7 重定位

- 重定位节和符号定义
- 重定位节中的符号引用
- 重定位条目
- 重定位符号引用



### 7.8 可执行目标文件

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-09 13-00-53.png)



### 7.9 加载可执行目标文件

- 加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-30 19-43-07.png)

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-30 19-51-18.png)



### 7.10 动态链接共享库

- 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来，称为动态链接
- 共享库在Linux系统中通常用.so后缀表示
- 微软操作系统的共享库称为DLL(动态链接库)
- 在任何给定的文件系统中，对于一个库只有一个.so文件，所有引用该库的可执行目标位文件共享这个.so文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-10-30 20-09-02.png)

### 7.11 从应用程序中加载和链接共享库

- 还可能在它运行时要求动态链接器加载和链接某个共享库
- 分发软件和构造高性能的Web服务器
- Linux系统的 dlopen函数动态加载和链接共享库
- dlsym
- dlclose
- dlerror

### 7.12 位置无关代码

- 可以加载而无需重定位的代码称为位置无关代码(PIC), 用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码
- PIC数据引用
- PIC函数调用
- 全局偏移量表GOT
- 过程连接表PLT



### 7.13 库打桩机制

- 允许截获对共享库函数的调用，取而代之执行自己的代码
- 编译时打桩
- 链接时打桩
- 运行时打桩

### 第八章　异常控制流

- ECF

### 8.1 异常

- 异常就是控制流中的突变，用来响应处理器状态中的某些变化
- 异常处理
  - 异常号
    - 由处理器的设计者分配，如算术运算溢出
    - 由操作系统内核(操作系统常驻内存的部分)的设计者分配的，如系统调用
  - 在操作系统启动时，会分配和初始化一张称为异常表的跳转表，使得表目k包含异常k的处理程序的地址

- 异常的类别

  - 中断
  - 陷阱
  - 故障
  - 终止
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-01 15-43-19.png)

  - 中断

    - 硬件中断的异常处理程序常常称为中断处理程序

  - 陷阱和系统调用

    - 陷进最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-01 15-49-21.png)

    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-01 15-51-04.png)

  - 故障
    - 由错误引起，如果处理程序能够修正错误，它将控制返回到引起故障的指令，否则，处理程序返回到内核中的abort例程，终止引起故障的应用程序
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-01 15-55-46.png)

  - 终止
    - 终止处理程序将控制传递给一个内核abort例程，该例程会终止这个应用程序

- Linux/x86-64系统中的异常

  - 0-31的号码是由Intel架构师定义的异常
  - 32-255的号码对应的是操作系统定义的中断和陷阱
  - Linux/x86-64故障和终止
    - 除法错误，Linux　shell报告为浮点异常
    - 一般保护故障，通常是因为一个程序引用了一个未定义的虚拟内存区域，或程序试图写一个只读的文本段，　Linux shell报告为段故障(segmentation fault)
    - 缺页
  - Linux/x86-64系统调用
    - 每个系统调用都有一个唯一的整数号，对应到一个内核中跳转表的偏移量
    - 在x86-64系统上，系统调用是通过一条称为syscall的陷阱指令来提供的
    - 所有到Linux系统调用的参数都是通过通用寄存器而不是栈传递的

### 8.2 进程

- 异常是允许操作系统内核提供进程概念的基本构造块
- 进程的经典定义是一个执行中程序的实例
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-01 16-28-02.png)

- 逻辑控制流
  - 进程为每个程序提供了一种假象，好像程序在独占地使用处理器
- 并发流
  - 一个逻辑流的执行时间与另一个流重叠，称为并发流
  - 并行流: 两个流并发地运行在不同的处理器核或计算机上
- 私有地址空间
  - 进程为每个程序提供一种假象，好像它独占地使用系统地址空间
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-01 16-36-41.png)

- 用户模式和内核模式
  - 控制寄存器中的一个模式位
  - 当设置了模式位时，进程就运行在内核模式中，可以执行指令集中的任何指令，可以访问系统的任何内存位置
  - 没有设置模式位时，进程运行在用户模式中，不允许执行特权指令
  - 运行应用程序代码的进程初识时是在用户模式中的，进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或陷入系统调用这样的异常
- 上下文切换
  - 实现多任务
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-01 16-47-35.png)

### 8.3 系统调用错误处理

- 当Unix系统级函数遇到错误时，它通常会返回-1.并设置全局整数变量errno来表示什么出错了
- 错误处理包装函数

### 8.4 进程控制

- Unix提供了大量从C程序中操作进程的系统调用

- 获取进程ID

  - getpid
  - getppid

- 创建和终止进程

  - 运行
    - 在CPU上运行，或在等待被执行且最终会被内核调用
  - 停止
    - 进程的执行被挂起，且不会被调度。当收到SIGSTOP SIGTSTP SIGTTIN或者SIGTTOU信号时，进程就停止，直到收到一个SIGCONT信号，进程再次运行
  - 终止
    - 进程永远地停止了，收到终止进程信号或从主程序返回或调用exit函数
  - exit函数以status退出状态来终止进程
  - fork
    - 子进程得到与父进程用户级虚拟地址空间相同的一份副本，包括代码和数据段、堆、共享库以及用户栈，子进程还获得与父进程任何打开文件描述符相同的副本
    - 调用一次，返回两次
    - 并发执行，父进程和子进程是并发运行的独立进程
    - 相同但独立的地址空间，每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。但是父进程和子进程都有自己的私有地址空间
    - 共享文件，子进程继承了父进程所有的打开文件
  - 进程图
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-05 19-02-12.png)
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-05 19-05-37.png)
      - 父进程的输出是 p2: x=0
      - 子进程的输出是  p1:x=2  p2:x=1

- 回收子进程

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-05 19-09-31.png)

  - 一个父进程终止了，内核会安排init进程成为它的孤儿进程的养父，它不会终止，是所有进程的祖先，是在系统启动时由内核创建的，即使僵死子进程没有运行，它们仍然消耗系统的内存资源
  - waitpid
    - 修改默认行为　options
    - 检查已回收子进程的退出状态
    - 错误条件
  - wait函数

- 让进程休眠

  - sleep函数将一个进程挂起一段指定时间
  - pause函数，让调用进程休眠，直到该进程收到一个信号

- 加载并运行程序

  - execve函数在当前进程的上下文中加载并运行一个新程序，调用一次，从不返回，除非出现错误时
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-05 19-46-35.png)

  - 在execve加载了filename后，启动代码设置栈，并将控制传递给新程序的主函数
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-05 19-51-36.png)

- 利用fork和execve运行程序
  - 如Unix shell
  - Web服务器

### 8.5 信号

- 低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的、信号提供了一种机制，通知用户进程发生了这些异常

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-06 16-22-55.png)

- 信号术语

  - 传送一个信号到目的进程

    - 发送信号，内核通过更新目的进程上下文中某个状态，发送一个信号给目的进程
    - 接收信号，当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-06 16-32-22.png)

    - 一个发出而没有被接收的信号叫做待处理信号

- 发送信号

  - 进程组
    - getpgrp
    - setpgid
  - 用/bin/kill程序发送信号
    - /bin/kill  -9  15213  发送信号9给进程15213
  - 从键盘发送信号
    - 作业(job): 对一条命令行求值而创建的进程
    - 如　ls  | sort  由两个进程组成的前台作业
    - Ctrl+ C 会导致内核发送一个SIGINT信号到前台进程组中的每个进程
    - Ctrl+Z 会发送一个SIGSTP信号到前台进程组中的每个进程
  - 用kill 函数发送信号
    - 通过调用kill函数发送信号给其他进程
    - kill
  - 用alarm函数发送信号
    - 进程通过调用alram函数向它自己发送SIGALRM信号

- 接受信号

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-06 16-50-34.png)

  - 通过使用signal函数修改和信号相关联的默认行为，SIGSTOP和SIGKILL是不能修改的
  - signal也可以设置信号处理程序
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-06 16-56-44.png)

- 阻塞和解除阻塞信号

  - 隐式阻塞机制，内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号
  - 显式阻塞机制，使用函数

- 编写信号处理程序

  - 安全的信号处理
    - 处理程序和主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰
    - 处理程序要尽可能简单
    - 在处理程序中只调用异步信号安全的函数
    - 信号处理程序中产生输出唯一安全的方法是使用write函数
    - 保存和恢复errno
    - 阻塞所有的信号，保护对共享全局数据结构的访问
    - 用volatile声明全局变量，volatile限定符强迫编译器每次在代码中引用g时，都要从内存中读取g的值
    - 用sig_atomic_t声明标志
  - 正确的信号处理
    - 未处理的信号是不排队的，不可以用进程来对其他进程中发生的事件计数
    - 只要有一个子进程终止或停止，内核就会发送一个SIGCHILD信号给父进程
    - 僵死进程，在ps命令的输出中由字符串 "defunct"声明
  - 可移植的信号处理

- 同步流以避免讨厌的并发错误

  - 通过在调用fork之前，阻塞SIGCHILD信号，然后在调用addjob之后取消阻塞这些信号，保证了子进程被添加到作业列表之后回收该子进程
  - 子进程继承了它们父进程的被阻塞集合，所以必须在调用execve之前，小心地解除子进程中阻塞的SIGCHILD信号

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-06 17-35-37.png)

  

​	 

- 显示地等待信号
  - 主程序显示地等待某个信号处理程序运行
  - sigsuspend函数暂时用mask替换当前的阻塞集合，然后挂起该进程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-06 17-50-19.png)

  

  

### 8.6 非本地跳转

- 将控制从一个函数转移到另一个当前正在执行的函数
- setjmp
- longjmp
- sigsetjmp
- siglongjmp函数是可以被信号处理程序使用的版本
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-06 19-25-32.png)

- C++和Java中的软件异常
  - 是较高层次的，是C语言的setjmp和longjmp函数的更加结构化的版本。try  catch

### 8.7 操作进程的工具

- strace 　打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。如　strace ./a.out
- 用-static编译的程序，能得到一个更加干净的、不带有大量与共享库相关的输出的轨迹
- ps 列出当前系统中的进程(包括僵死进程)
- top 打印出关于当前进程资源使用的信息
- pmap 显示进程的内存映射
- /proc 一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容
- cat /proc/loadavg　　可以看到平均负载

## 第九章　虚拟内存

- 虚拟内存(VM)是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互,它为每个进程提供了一个大的、一致的和私有的地址空间
- 虚拟内存
  - 将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域
  - 为每个进程提供了一致的地址空间
  - 它保护了每个进程的地址空间不被其他进程破坏

### 9.1 物理和虚拟寻址

- 物理寻址

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 18-35-39.png)

- 虚拟寻址
  - CPU通过一个虚拟地址(VA)来访问主存
  - CPU芯片上叫做内存管理单元(MMU)的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 18-38-43.png)

### 9.2 地址空间

- 地址空间是一个非负整数地址的有序集合
- 虚拟地址空间
  - 一个包含N=2^n个地址的虚拟地址空间叫做一个n位地址空间
  - 现代操作系统通常支持32位或64位虚拟地址空间
- 物理地址空间
  - M=2^m
- **允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间，这就是虚拟内存的思想，主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址**

### 9.3 虚拟内存作为缓存的工具

- 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都要一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。磁盘上的数据被分割成块，作为磁盘和主存之间的传输单元。VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块，大小为P=2^p字节，物理内存被分割为物理页,大小为P字节
- 虚拟页面的集合分为三个不相交的子集
  - 未分配的: VM系统还未分配的页，不占用任何磁盘空间
  - 缓存的: 当前已缓存在物理内存中的已分配页
  - 未缓存的: 未缓存在物理内存中的已分配页
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 18-54-09.png)

- DRAM缓存的组织结构

  - SRAM缓存表示位于CPU和主存之间的L1,L2和L3高速缓存
  - DRAM缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页
  - 大的不命中惩罚和访问第一个字节的开销
  - 虚拟页通常是4KB - 2MB
  - 任何虚拟页都可以放置在任何的物理页中
  - 操作系统对DRAM缓存使用了复杂精密的替换算法
  - DRAM缓存使用写回

- 页表

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-02-27.png)

  - 由操作系统软件、MMU和一个存放在物理内存中叫做页表的数据结构，页表将虚拟页映射到物理页
  - 页表就是一个页表条目(PTE)的数组
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-07-50.png)

- 页命中
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-12-15.png)

- 缺页

  - DRAM缓存不命中称为缺页
  - 缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-14-37.png)

  - 当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-16-51.png)

  - 在虚拟内存的习惯说法中，块被称为页，在磁盘和内存之间传送页的活动叫做交换或者页面调度
  - 页从磁盘换入(或者页面调入)DRAM和从DRAM换出(或者页面调出)磁盘
  - 当有不命中发送时，才换入页面，称为按需页面调度

- 分配页面

  - malloc分配虚拟页的实例
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-22-25.png)

- 局部性
  - 尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面集合上工作，这个集合叫做工作集。
  - 如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动，这时页面将不断换进换出。
  - 程序性能太慢时，考虑是不是发生了抖动
  - getrusage函数监测缺页的数量

### 9.5 虚拟内存作为内存管理的工具

- 实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。　多个虚拟页面可以映射到同一个共享物理页面上
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-31-24.png)

- VM简化了链接和加载、代码和数据共享，以及应用程序的内存分配
  - 简化链接
    - 独立的地址空间允许每个进程的内存映像使用相同的基本格式
  - 简化加载
    - 容易向内存中加载可执行文件和共享对象文件
    - 要把目标文件中.text和.data节加载到一个新创建的进程中，Linux加载器为代码和数据段分配虚拟页，把它们标记为未被缓存的，将页表条目指向目标文件中适当的位置
    - 将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射
  - 简化共享
    - 操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本
  - 简化内存分配
    - 当一个运行在用户进程中的程序要求额外的堆空间时(如调用malloc的结果)，操作系统分配一个适当数字个连续的虚拟内存页面，并且将它们映射到物理内存中任意的k个位置的物理页面

### 9.5 虚拟内存作为内存保护的工具

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-50-44.png)

- SUP位表示进程是否必须运行在内核模式下才能访问该页
- 如果一条指令违反了这些许可条件，CPU就会触发一个一般保护故障，将控制传递给一个内核中的异常处理程序，Linux shell一般将这种异常报告为"段错误(segmentation fault)"



### 9.6 地址翻译

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 19-56-55.png)

- 页表基址寄存器(PTBR)指向当前页表，n位的虚拟地址包含: 一个p位的虚拟页面偏移(VPO)和一个n-p位的虚拟页号(VPN), MMU利用VPN来选择适当的PTE.
  - 将PPN和VPO串联起来就能得到相应的物理地址
  - 页面命中完全是由硬件来处理的，处理缺页要求硬件和操作系统内核协作完成
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-07 20-04-55.png)

- 总和高速缓存和虚拟内存

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 19-33-01.png)

- 利用TLB加速地址翻译
  - 在MMU中包括了一个关于PTE的小的缓存，称为翻译后背缓冲器(TLB)
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 19-39-02.png)

- 多级页表

  - 如果一级页表中的一个PTE是空的，二级页表就不需要存在
  - 只有一级页表才需要总是在主存中，虚拟内存系统可以在需要时创建、页面调入或调出二级页表，只有最经常使用的二级页表才需要缓存在主存中
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 19-49-32.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 19-51-09.png)

- 综合: 端到端的地址翻译

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-06-26.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-07-07.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-07-27.png)

### 9.7 案例研究: Intel Core i7/Linux内存系统

- 现在的Core i7实现支持48位虚拟地址空间和52位物理地址空间
- 处理器封装包括: 四个核，一个大的所有核共享的L3高速缓存，以及一个DDR3内存控制器，每个核包含一个层次结构的TLB,一个层次结构的数据和指令高速缓存
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-13-59.png)

- Linux使用4KB的页

- Core i7地址翻译

  - 采用四级页表层次结构
  - 与已分配了的页相关联的页表都是驻留在内存中的
  - CR3控制寄存器指向第一级页表的起始位置，CR3的值是每个进程上下文的一部分
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-18-53.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-22-29.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-23-21.png)

  - 要求物理页4KB对齐
  - 通过限制只能执行只读代码段，使得操作系统内核降低了缓冲区溢出攻击的风险
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-28-35.png)

- Linux虚拟内存系统

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-31-45.png)

  - Linux虚拟内存区域

    - Linux将虚拟内存组织成一些区域(或段)的集合
    - 内核为系统中的每个进程维护一个单独的任务结构，包含该进程运行所需要的信息
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-36-24.png)

    - pgd指向第一级页表的基址，而mmap指向一个区域结构的链表，描述了当前虚拟地址空间的一个区域，当内核运行这个进程时，就将pgd存放在CR3控制寄存器中

  - Linux缺页异常处理

    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-42-04.png)

### 9.8 内存映射

- Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容

- 虚拟内存区域可以映射到两种类型的对象中的一种

  - LInux文件系统中的普通文件，一个区域可以被映射到一个普通磁盘文件的连续部分，按需进行页面调度
  - 匿名文件，匿名文件由内核创建，包含全是二进制0
  - 一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件(交换空间)之间换来换去。在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。

- 再看共享对象

  - 一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-53-23.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-54-49.png)

  - 私有对象使用写时复制的技术被映射到虚拟内存中

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-57-14.png)

    

- fork函数

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 20-59-59.png)

- execve函数
  - execve("a.out", NULL, NULL)
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 21-07-44.png)

- 使用mmap函数的用户级内存映射
  - 使用mmap函数创建新的虚拟内存区域，并将对象映射到这些区域中
  - munmap函数删除虚拟内存的区域
  - 使用mmap将一个任意大小的磁盘文件复制到stdout
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-11 21-14-08.png)

### 9.9 动态内存分配

- 使用低级mmap和munmap函数来创建和删除虚拟内存区域，但是用动态内存分配器更方便
- 动态内存分配器维护者一个进程的虚拟内存区域，即堆
- 对于每个进程，内核维护着一个变量brk,指向堆的顶部
- 分配器将堆视为一组不同大小的块的集合来维护，每个块就是一个连续的虚拟内存片
- 显式分配器: malloc free  new delete
- 隐式分配器:  自动释放未使用的已分配的块的过程，垃圾收集，Java等语言
- malloc和free函数
  - malloc从堆中分配块，返回一个指针，指向大小至少为size字节的内存块，对齐，在64位模式中，该地址总是16的倍数
  - malloc不初始化它返回的内存
  - calloc函数将分配的内存初始化为0
  - realloc函数，改变一个以前分配块的大小
  - sbrk函数通过将内核的brk指针增加incr来扩展和收缩堆
  - free
  - 假设字是4字节的对象
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 16-45-28.png)

- 为什么使用动态内存分配
  - 直到程序运行时，才知道某些数据结构的大小
- 分配器的要求和目标
  - 只使用堆
  - 对齐块
  - 不修改已分配的块
  - 一个系统中被所有进程分配的虚拟内存的全部数量是受磁盘上交换空间的数量限制的，虚拟内存是一个有限的空间，必须高效地使用
- 碎片
  - 当虽然有未使用的内存但不能用来满足分配请求时，
  - 内部碎片和外部碎片
    - 内部碎片是在一个已分配块比有效载荷大时发生
    - 外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的
- 实现问题
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 17-09-27.png)

- 隐式空闲链表

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 17-10-33.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 17-12-50.png)

  - 简单，但是任何操作的开销，都要进行搜索
  - 系统对齐要求和分配器对块格式的选择会对分配器的最小块大小有强制的要求

- 放置已分配的块

  - 当一个应用请求一个k字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所情况块的空闲块
  - 首次适配
  - 下一次适配
  - 最佳适配

- 分割空闲块

  - 将空闲块分割成两部分

- 获取额外的堆内存

  - 通过调用sbrk函数，向内核请求额外的堆内存，分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中

- 合并空闲块

  - 邻接的空闲块，　假碎片
  - 合并相邻的空闲块

- 带边界标记的合并

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 18-37-02.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 18-38-33.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 18-43-53.png)

- 综合: 实现一个简单的分配器

  - 通用分配器设计
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 18-52-13.png)

  - 操作空闲链表的基本常数和宏
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 18-55-42.png)

  - 创建初始空闲链表
  - 释放和合并块
  - 分配块
    - 如果分配器不能发现一个匹配的块，那么就用一个新的空闲块来扩展堆，把请求块放在这个新的空闲块中，可选地分割这个块，然后返回一个指针，指向这个新分配的块

- 显式空闲链表

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-03-53.png)

- 分离的空闲链表



### 9.10 垃圾收集

- 垃圾收集器是一种动态内存分配器，自动释放程序不再需要的已分配块，这些块被称为垃圾

- 垃圾收集器的基本知识

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-09-21.png)

  - 不可达节点对应于垃圾
  - C和C++语言的收集器不能维持可达图的精确表示，保守的垃圾收集器

- Mark & Sweep垃圾收集器
  - 标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块，块头部中空闲的低位中的一位通常用来表示这个块是否被标记了
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-19-28.png)

- C 程序的保守Mark & Sweep
  - C程序的Mark & Sweep收集器必须是保守的，其根本原因是C语言不会用类型信息来标记内存位置

### 9.11 C程序中常见的与内存有关的错误

- 间接引用坏指针

  - 在进程的虚拟地址空间中有较大的洞，没有映射到任何有意义的数据，如果试图间接引用一个指向这些洞的指针，那么操作系统会以段异常终止程序
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-32-56.png)

- 读未初始化的内存

  - bss内存位置(如未初始化的全局C变量)总是被加载器初始化为0.但对于堆内存却不是这样的。一个常见的错误是假设堆内存被初始化为0
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-33-15.png)

- 允许栈缓冲区溢出

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-33-34.png)

- 假设指针和它们所指向的对象是相同大小的

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-33-57.png)
  - 可能会写到超出A数组结尾的地方

- 造成错位错误

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-34-28.png)

  - 在这个过程中覆盖了A数组后面的某个内存位置

- 引用指针，而不是它所指向的对象

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-37-20.png)

- 误解指针运算
  - 指针的算术操作是以它们指向的对象的大小为单位来进行的
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-39-00.png)

- 引用不存在的变量
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-39-36.png)

- 引用空闲堆块中的数据
  - 引用已经被释放了的堆块中的数据
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-41-13.png)

- 引起内存泄露
  - 不小心忘记释放已分配块
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-12 19-42-23.png)



## 第十章　系统级I/O

- 输入操作是从I/O设备复制数据到主存，输出操作从主存复制数据到I/O设备
- 在Linux中，是通过内核提供的系统级Unix I/O函数来实现较高级别的I/O函数的

### 10.1 Unix I/O

- 一个Linux文件就是一个m字节的序列，所有的I/O设备(如网络、磁盘和终端)都被模型化为文件，所有的输入和输出都被当作对相应文件的读和写来执行
- Unix I/O
  - 打开文件
  - Linux shell创建的每个进程开始时都有三个打开的文件: 标准输入　标准输出　标准错误
  - 改变当前的文件位置
  - 读写文件
  - 关闭文件

### 10.2 文件

- 每个Linux文件都有一个类型来表明它在系统中的角色
  - 普通文件
    - 文本文件　只含ASCII或Unicode字符的普通文件
    - 二进制文件
  - 目录
    - 是包含一组链接的文件，每个链接都将一个文件名映射到一个文件
  - 套接字
    - 用来与另一个进程进行跨网络通信的文件
  - 命令通道
  - 符号链接
  - 字符
  - 块设备

### 10.3 打开和关闭文件

- open
- close

### 10.4 读和写文件

- read
- write
- size_t 被定义为unsigned long   ssize_t被定义为long
- 有时，read和write传送的字节比应用程序要求的要少，这些不足值不表示有错误
  - 读时遇到EOF
  - 从终端读文本行
  - 读和写网络套接字

### 10.5 用RIO包健壮地读写

- Robust I/O (RIO),会自动处理不足值
  - 无缓冲的输入输出函数，直接在内存和文件之间传送数据，没有应用级缓冲
  - 带缓冲的输入函数，文件的内容缓存在应用级缓冲区内
- RIO的无缓冲的输入输出函数
  - rio_readn
  - rio_writen
  - 允许被中断的系统调用，且在必要时重启
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-10-29.png)

- RIO的带缓冲的输入函数
  - 从一个内部读缓冲区复制一个文本行，当缓冲区变空时，会自动调用read重新填满缓冲区
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-57-44.png)
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-58-09.png)
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-58-32.png)

### 10.6 读取文件元数据

- stat
- fstat

### 10.7 读取目录内容

- opendir 以路径名为参数，返回指向目录流的指针
- readdir 返回指向流dirp中下一个目录项的指针
- closedir关闭流并释放其所有的资源

### 10.8 共享文件

- 内核用三个相关的数据结构来表示打开的文件
  - 描述符表，每个进程都有它独立的描述符表
  - 文件表，打开文件的集合是由一张文件表来表示的，所有的进程共享这张表，每个文件表项包括当前的文件位置、引用技术、一个指向v-node表中对应表项的指针
  - v-node表　所有进程共享这张v-node表，每个表项包含stat结构中的大多数信息
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-27-30.png)

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-28-32.png)

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-29-41.png)

### 10.4 I/O重定向

- ls >foo.txt
- dup2函数复制描述符表表项oldfd到描述符表项newfd
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-36-25.png)

### 10.10 标准I/O

- C语言定义了一组高级输入输出函数，称为标准I/O库
- fopen fclose
- fread fwrite
- fgets fputs
- scanf printf
- 标准I/O库将一个打开的文件模型化为一个流，一个流就是一个指向FILE类型的结构的指针
- 流缓冲区的目的和RIO读缓冲区的一样，就是使开销较高的Linux I/O系统调用的数量尽可能小
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-41-10.png)

### 10.11 I/O函数

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-41-54.png)

- 较高级别的I/O和标准I/O都是基于Unix I/O函数实现的
- 标准I/O函数提供了Unix I/O函数的一个更加完善的带缓冲的替代品
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-44-53.png)

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-48-05.png)

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-13 20-48-39.png)

## 第11章　网络编程

### 11.1 客户端-服务器编程模型

- 客户端和服务器是进程

### 11.2 网络

### 11.3 全球IP因特网

- IP地址

  - TCP/IP为任意整数数据项定义了统一的网络字节顺序(大端字节顺序)

  - hostname -i  检测本机的网络地址
  - hostname  本机的域名

- 因特网域名

  - nslookup程序能展示与某个IP地址对应的域名
  - 每台因特网主机都有本地定义的域名　localhost, 映射为loopback 地址127.0.0.1
  - nslookup localhost

- 因特网连接



### 11.4 套接字接口

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-14 17-23-46.png)

- 套接字地址结构

  - _in后缀是互联网的缩写

- 主机和服务的转换

  - LInux提供了getaddrinfo和getnameinfo实现二进制套接字地址结构和主机名、主机地址、服务名和端口号的字符串表示之间的相互转换。使得能编写独立于任何特定版本的IP协议的网络程序

  - getaddrinfo函数

    - 将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构
    - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-14 17-32-51.png)

    - 调用freeaddrinfo释放该链表

  - getnameinfo函数

    - 将一个套接字名转化成相应的主机和服务名字符串

- 套接字接口的辅助函数

  - open_clientfd函数　客户端建立与服务器的连接
  - open_listenfd函数　服务器创建一个监听描述符，准备好接收连接请求

- echo客户端和服务器的示例

- EOF

  - EOF是由内核检测到的一种条件，应用程序在它接收到一个由read函数返回的零返回码时，它就会发现出EOF条件。对于磁盘文件，当前文件位置超出文件长度时，会发生EOF,对于因特网连接，当一个进程关闭连接它的那一端时，会发生EOF,连接另一端的进程在试图读取流中最后一个字节之后的字节时，会检测到EOF

### 11.5 Web服务器

- Web内容

  - 内容是一个与MIME类型相关的字节序列
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-14 19-09-13.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-14 19-10-07.png)

  - 通用资源定位符(URL)
    - 客户端使用前缀
    - 服务器端使用后缀

- http事务

  - Http请求
  - Http响应

- 服务动态内容

  - GCI(通用网关接口)
  - 客户端如何将程序参数传递给服务器
  - 服务器如何将参数传递给子进程
  - 服务器如何将其他信息传递给子进程
  - 子进程将它的输出发送到哪里

## 第12 章　并发编程

- 如果逻辑控制流在时间上重叠，那么它们就是并发的
- 并发不仅仅局限于内核，它也可以在应用程序中扮演重要角色(并发程序)
- 三种构造并发程序的方法:
  - 进程，每个逻辑控制流都是一个进程
  - I/O多路复用，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流，所有的流共享同一个地址空间
  - 线程，线程是运行在一个单一进程上下文中的逻辑流，像进程流一样由内核进行调度，而像I/O多路复用流一样共享同一个虚拟地址空间

### 12.1 基于进程的并发编程

- exec fork  waitpid 
- 基于进程的并发服务器
- 进程的优劣
  - 对于在父子进程间共享状态信息，进程有一个非常清晰的模型: 共享文件表，但是不共享用户地址空间
  - 独立的地址空间使得进程共享状态信息变得更加困难，为了共享信息，它必须使用显式的IPC(进程间通信)机制
  - 进程控制和IPC的开销很高，比较慢

### 12.2 基于I/O多路复用的并发编程

- 使用select函数，要求内核挂起进程，只有在一个或多个I/O事件发生后，才将控制返回给应用程序

- 基于I/O多路复用的并发事件驱动服务器
  - 可用作并发事件驱动程序的基础
  - 将逻辑流模型化为状态机
  - 现代高性能服务器(如Node.js  nginx 和　Tornado)使用的都是基于I/O多路复用的事件驱动的编程方式
- I/O多路复用技术的优劣
  - 比基于进程的设计给了程序员更多的对程序行为的控制，如为某些客户端提供它们所需的服务
  - 运行在单一进程上下文中，每个逻辑流都可以访问该进程的全部地址空间，使得在流之间共享数据很容易
  - 可以利用GDB调试，比基于进程的设计要高效得多
  - 编码复杂，随着并发粒度的减小，复杂性还会上升
  - 不能充分利用多核处理器

### 12.3 基于线程的并发编程

- 线程是前两种方法的混合，线程是运行在进程上下文中的逻辑流
- 线程由内核自动调度，每个线程有自己的线程上下文，包括线程ID, 栈，栈指针，程序计数器，通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间
- 基于线程的逻辑流结合了基于进程和基于I/O多路复用的流的特性。同进程一样，由内核自动调度。同I/O多路复用一样，多个线程运行在单一进程的上下文中，共享这个进程虚拟地址空间的所有内容，包括它的代码，数据，堆，共享库，打开的文件
- 线程执行模型
  - 一个线程的上下文比一个进程的上下文小得多
  - 和一个进程相关的线程组成一个对等线程池，独立于其他线程创建的线程
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 19-06-37.png)

- Posix线程(Pthreads)
- 创建线程
- 终止线程
- 回收已终止线程的资源
- 分离线程
  - 一个可结合的线程能够被其他线程收回和杀死，它的内存资源在被其他线程回收之前，是不可释放的
  - 一个分离的线程是不能被其他线程回收或杀死的，它的内存资源在它终止时由系统自动释放
- 初始化线程
- 基于线程的并发服务器
- 线程运行在同一个进程中，它们都共享相同的描述符表，无论多少线程使用这个已连接描述符，这个已连接描述符的文件表的引用计数都等于1

### 12.4 多线程程序中的共享变量

- **一个变量是共享的，当且仅当多个线程引用这个变量的某个实例**
- 线程内存模型
  - 每个线程都有自己独立的线程上下文，包括线程ID, 栈，栈指针，程序计数器，通用目的寄存器和条件码，每个线程和其他线程一起共享进程上下文的剩余部分
  - 寄存器是从不共享的，而虚拟内存总是共享的
  - 各自独立的线程栈的内存模型不是那么整齐清楚的，这些栈被保存在虚拟地址空间的栈区域中，并且通常是被相应的线程独立地访问的
  - 线程以某种方式得到一个指向其他线程栈的指针，它就可以读写这个栈的任何部分
  - 像msgs这样的本地自动变量也能被共享
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 19-34-08.png)

- 将变量映射到内存
  - 全局变量，在运行时，虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用
  - 本地自动变量，在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例
  - 本地静态变量，定义在函数内部且有static属性的变量，虚拟内存的读/写区域只包含在程序中声明的每个本地静态变量的一个实例，每个对等线程都读和写这个实例
- 共享变量
  - **变量v是共享的，当且仅当它的一个实例被一个以上的线程引用**

### 12.5 用信号量同步线程

- 每个并发执行定义了两个线程中的指令的某种全序(或交序)，没有办法预测你的操作系统是否将为你的线程选择一个正确的顺序
- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 19-49-26.png)

- 进度图

  - 进度图将n个并发线程的执行模型化为一条n维笛卡尔空间中的轨迹线
  - 临界区
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 19-53-06.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 19-54-32.png)

- 信号量
- 使用信号量来实现互斥
  - 将每个共享变量(或一组)与一个信号量联系起来，然后用P(s)和V(s)操作将相应的临界区包围起来，也称为互斥锁
  - 信号量操作确保了对临界区的互斥访问
  - 在多处理器上的局限性，多处理器上一组CPU/高速缓存对共享同一个主存
- 利用信号量来调度共享资源
- Pthread互斥锁被用来实现互斥，条件变量用来调度对共享资源的访问
- 基于线程的事件驱动程序

### 12.6 使用线程提高并行性

- ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 20-10-40.png)

- 同步开销巨大，要尽可能避免，如果无可避免，必须尽可能多的有用计算弥补这个开销
- 使用局部变量来消除不必要的内存引用
- 并行程序常常被写为每个核上只运行一个线程

### 12.7 其他并发问题

- 线程安全
  - 一个函数当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果
  - 四个线程不安全函数类
    - 不保护共享变量的函数
    - 保持跨越多个调用的状态的函数
    - 返回指向静态变量的指针的函数
      - 利用加锁－复制技术，在每一个调用位置，对互斥锁加锁，调用线程不安全函数，将函数返回的结果复制到一个私有的内存位置，然后对互斥锁解锁
    - 调用线程不安全函数的函数
- 可重入性
  - 一类重要的线程安全函数，可重入函数，当它们被多个线程调用时，不会引用任何共享数据
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 20-31-30.png)

- 在线程化的程度中使用已存在的库函数

  - 大多数Linux函数，包括定义在标准C库中的函数都是线程安全的，只有一小部分是例外
  - Linux系统提供大多数线程不安全函数的可重入版本，以"_r"后缀结尾

- 竞争

  - 当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点时，就会发生竞争

- 死锁

  - 一组线程被阻塞了，等待一个永远也不会为真的条件
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-11-19 20-47-19.png)

  - 互斥锁加锁顺序规则
    - 给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的