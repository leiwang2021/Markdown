# CSAPP

## 第一章　计算机系统漫游

### 1.1 信息就是位+上下文

- 源程序是由值0和1组成的位序列，字节序列
- 只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件

### 1.2 程序被其他程序翻译成不同的格式

- gcc -o hello  hello.c
- 编译系统
  - 预处理器(cpp) 读取系统头文件插入到程序文本中，得到修改了的源程序 hello.i

  - 编译器(ccl)将文本文件hello.i 翻译成hello.s  包含一个汇编语言程序,包含函数main的定义

  - 汇编器(as)将hello.s翻译成机器语言指令，得到可重定位目标程序的二进制文件hello.o

  - 链接器(ld)合并hello.o和printf函数的printf.o目标文件，得到可执行目标文件hello,可被加载到内存中，由系统执行

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-04-24.png)

### 1.3 编译系统

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞，缓冲区溢出错误是造成大多数网络安全漏洞的主要原因

### 1.4 处理器读取并解释存储在内存中的指令

- 系统的硬件组成
  - 总线：总线被设计成传送定长的字节块
  - I/O设备
  - 主存，临时存储设备，用于存放程序和程序处理的数据，DRAM
  - 处理器，执行存储在主存中指令的引擎
- 运行hello程序
  - 代码和数据从磁盘复制到主存，再从主存复制到寄存器，再从寄存器文件中复制到显示设备

### 1.5　高速缓存

- 高速缓存存储器存放经常访问的数据，提高访问速度　　SRAM

- 在处理器和主存之间插入一个高速缓存可以提高速度

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-05-12.png)

### 1.6 存储设备层次结构

- 上一层的存储器作为低一层存储器的高速缓存

- 可以利用对整个存储器层次结构的理解提高程序性能

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-05-36.png)

### 1.7 操作系统管理软件

- 所有应用程序对硬件的操作尝试都必须通过操作系统

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-06-02.png)

- 操作系统两个基本功能
  - 防止硬件被失控的应用程序滥用
  - 向应用程序提供简单一致的机制来控制复杂的硬件设备

- 操作系统通过基本的抽象概念(进程、虚拟内存和文件)实现
  - 文件是对I/O设备的抽象表示
  - 虚拟内存是对主存和磁盘I/O设备的抽象表示
  - 进程是对处理器、主存和I/O设备的抽象表示

- 进程

  - 进程是操作系统对一个正在运行的程序的一种抽象
  - 并发运行: 一个进程的指令和另一个进程的指令是交错执行的
  - 上下文:跟踪进程运行所需的所有状态信息
  - 上下文切换: 切换进程
  - 从一个进程到另一个进程的转换是操作系统内核管理的，内核是操作系统代码常驻主存的部分，内核是系统管理全部进程所用代码和数据结构的集合

- 线程

  - 一个进程实际上可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据

- 虚拟内存

  - 为每个进程提供一个假象，即每个进程都独占地使用主存

  - 每个进程看到的内存都是一样的，称为虚拟地址空间

  - 程序代码和数据

  - 堆: 在运行时可动态扩展和收缩

  - 共享库: 存放像C标准库的代码和数据

  - 栈: 编译器用它来实现函数调用

  - 基本思想是把一个进程虚拟内存的内容存储在磁盘上，用主存作为磁盘的高速缓存

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-00-57.png)

- 文件
  - 文件就是字节序列，每个I/O设备都可看成文件
  - 系统中的所有输入输出都是通过Unix I/O的系统函数调用读写文件来实现的

### 1.8 系统之间利用网络通信

- 系统从主存复制一串字节到网络适配器，数据流过网络到达另一台机器

### 1.9

- Amdahl定律，想要显著加速整个系统，必须提升全系统中相当大的部分的速度

- 并发: 一个同时具有多个活动的系统

- 并行: 用并发来使一个系统运行得更快

- 线程级并发

  - 多处理器系统

  - 超线程: 同时多线程，允许一个CPU执行多个控制流的技术

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-22-44.png)

- 指令级并发

  - 同时执行多条指令
  - 若处理器可以达到比一个周期一条指令更快的执行速率，就称为超标量处理器

- 单指令、多数据并发

  - 一条指令可以产生多个可以并行执行的操作

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-35-39.png)

## 第2章　信息的表示和处理

### 2.1 信息存储

- 大多数计算机使用8位的块，即字节作为最小的可寻址的内存单元
- 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存，内存的每一个字节都由一个唯一数字标识，称为地址，地址的集合称为虚拟地址空间
- 字长: 指明指针数据的标称大小，决定虚拟地址空间的最大大小，64位机器可以运行32位机器编译的程序
- 32位程序和64位程序，区别在于程序是如何编译的，而不是其运行的机器类型
- 指针在Win32下的大小为4字节，x64下的大小为8字节
- 寻址和字节顺序
  - 多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址
  - 字节顺序: 从高位地址还是从低位地址存储
  - 小端法和大端法，与机器有关，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则
  - sizeof(T) 返回存在一个类型为T的对象所需要的字节数
  - man ascii可得到一张ASCII字符码的表
- Unicode标准
  - UTF-8表示将每个字符编码为一个字节序列
  - 所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的
- 表示代码
  - 即使完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的，二进制代码很少能在不同的机器和操作系统组合之间移植
  - 程序仅仅只是字节序列
- 布尔代数:  用位向量对集合进行编码
- 逻辑运算和位运算
  - &&       &
  - ||        |
- 移位运算
  - 逻辑右移：左端补k个0
  - 算术右移: 左端补k个最高有效位的值
  - 对于有符号数，默认使用算术右移，对于无符号数，逻辑右移

### 2.2 整数表示

- 无符号数的编码
- 补码编码表示有符号整数
  - 最高有效位为符号位
  - 最小值为10000000000...
  - 最大值为01111111111...
- 有符号数和无符号数之间的转换
  - 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式
- C语言中的有符号数和无符号数
  - 一个有符号数和无符号数运算，隐式地将有符号数强制转换为无符号数
- 扩展一个数字的位表示
- 截断数字
- 有符号数到无符号数的隐式类型转换可能会导致程序错误

### 2.3 整数运算

- 无符号加法
  - 可能会溢出
- 补码加法
- 补码的非
- 无符号乘法
- 补码乘法
- 乘以常数
- 除以2的幂

### 2.4 浮点数

- 二进制小数
- IEEE浮点表示
  - 符号
  - 尾数
  - 阶码
- 舍入
- 浮点运算

### 2.5 总结

- 64位程序的优势是可以突破32位程序具有的4GB地址限制
- 大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码
- 使用位级运算和算术运算组合的方法



## 第三章　程序的机器级表示

- 历史观点

  - 8086　第一代单芯片、16位微处理器之一

  - Intel处理器系列，即x86
  - IA32, Intel 32位体系结构
  - x86-64 Intel64位体系结构

### 3.2 程序编码

  - linux  gcc  -Og -o p p1.c p2.c

  - gcc指GCC C编译器，是Linux上默认的编译器，编译选项 -Og生成符合原始C代码整体结构的机器代码的优化等级。

  - 首先，C预处理器扩展源代码，插入头文件代码，扩展宏；其次，编译器产生两个源文件的汇编代码，分别为p1.s和p2.s；接下来，汇编器将汇编代码转成二进制目标代码文件p1.o p2.o，目标代码是机器代码的一种形式，包含所有指令的二进制表示。最后，链接器将两个目标代码文件与实现库函数的代码合并，并产生最终的可执行代码文件p(由命令行选项-o p指定)

  - 机器级代码

    - 指令体系结构或指令集架构(ISA)定义机器级程序的格式和行为

    - 程序内存包括:  程序的可执行机器代码、操作系统需要的一些信息、用来管理过程调用、返回的运行时栈、用户分配的内存块

    - -S选项可看到C编译器产生的汇编代码　　gcc -Og -S  p1.c　　生成p1.s

    - gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
      后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。
      编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。

    - -c命令行选项，GCC会编译并汇编该代码  生成p1.o 二进制格式

    - 如何展示程序的字节表示: 

      - 用反汇编器确定代码长度为14
      - 运行GNU调试工具GDB     在文件mstore.o上运行GDB,然后  输入命令　(gdb) x/14xb multstore

    - 反汇编器

      - objdump  -d  mstore.o 
      - x86-64的指令长度从1到15个字节不等
      - 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码
      - 后缀q是是大小指示符

    - 生成实际可执行代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数　　-o生成可执行文件

      - gcc -Og -o prog main.c mstore.c

      - 链接器的任务之一是为函数调用找到匹配的函数的可执行代码的位置
      - 最后可能会插入字节，使得能更好地存放下一个代码块

- 格式的注解

  - 以.开头的行都是指导汇编器和链接器工作的伪指令
  - 在C语言中插入汇编代码的方法
    - 用汇编代码编写整个函数，在链接阶段把它们和C函数组合起来
    - 或者利用GCC的支持，直接在C程序中嵌入汇编代码

### 3.3 数据格式

- 大多数GCC生成的汇编代码指令都有一个字符的后缀，表明操作数的大小

### 3.4 访问信息

- 一个x86-64的CPU包含一组16个存储64位值的通用目的寄存器，这些寄存器用来存储整数数据和指针

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-09 15-17-55.png)

- 生成1字节和2字节数字的指令会保持剩下的字节不变，生成4字节数字的指令会把高位4个字节设置为0
- 操作数指示符
  - 操作数:  立即数(常数)　　寄存器值　　内存的值
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-09 15-30-37.png)
- 数据传送指令
  - MOV类，把数据从源位置复制到目的位置
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-09 15-36-10.png)

- 实例

  - 函数被调用点的指令ret
- 压入和弹出栈数据
  - 在x86-64中，程序栈存放在内存中某个区域
  - push  pop

### 3.5 算术和逻辑操作

- 加载有效地址
  - leaq
- 一元和二元操作
- 移位操作
- 特殊的算术运算

### 3.6 控制

- 条件码
  - CPU维护着一组单个位的条件码寄存器，它们描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令
- 访问条件码
- 跳转指令
- 用条件控制实现条件分支
- 用条件传送来实现条件分支
- 循环
  - 可以用条件测试和跳转组合起来实现循环的效果
- swith语句

### 3.7 过程

![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-21-22.png)

- 运行时栈
  - 栈和程序寄存器存放着传递控制和数据、分配内存所需的信息
  - x86-64的栈向低地址方向增长，栈指针%rsp指向栈顶元素
  - 当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间，这个部分称为过程的栈帧
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-25-37.png)
- 转移控制
  - call和ret
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-35-07.png)

- 数据传送
  - 通过寄存器最多传递6个整型参数，如果一个函数有大于6个整型参数，超出6个的部分就要通过栈来传递
  - 过程Q可以通过寄存器访问参数，有必要的话也可以通过栈访问
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 19-53-00.png)
- 栈上的局部存储
  - 一般来说，过程通过减小栈指针在栈上分配空间，分配的结果作为栈帧的一部分，标号为局部变量
  - 局部数据必须放在内存中的情况
    - 寄存器不足
    - 对一个局部变量使用地址运算符&
    - 某些局部变量是数组或结构
- 寄存器中的局部存储空间
  - 过程Q保存一个寄存器的值不变，要么是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值
  - 为什么不把所有的局部值都存储在被调用者保存寄存器中？在存储完6个局部变量之后，用完了所有的被调用者保存寄存器，所以剩下的两个值保存在栈上
- 递归过程
  - 递归调用一个函数本身与调用其他函数是一样的，每次函数调用都有它自己的私有状态信息(保存的返回位置和被调用者保存寄存器的值)存储空间
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-10 20-21-34.png)



### 3.8 数组分配和访问

- 在机器代码中，指针会被翻译成地址计算
- 指针运算
- 嵌套的数组
  - 数组元素在内存中按照行优先的顺序排列
- 定长数组
- 变长数组

### 3.9 异质的数据结构

- 结构

  - 结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址
  - 为了访问结构的字段，编译器产生的代码要将结构的地址加上适当的偏移

- 联合

  - 可以用来访问不同数据类型的位模式

- 数据对齐

  - 许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K的倍数，简化了形成处理器和内存系统之间接口的硬件设计
  - **对齐原则是任何K字节的基本对象的地址必须是K的倍数**
  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-11 15-43-53.png)

  - ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-11 15-44-26.png)

  - 编译器会为结构S2分配12个字节，最后3个字节是浪费的空间

  - 任何针对x86-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存，都必须满足16字节对齐

    - 任何内存分配函数生成的块的起始地址都必须是16的倍数
    - 大多数栈帧的边界都必须是16字节的倍数

  - **中间的插入填充和末尾的插入填充**　　　**按偏移量来计算填充的字节,偏移后满足对齐原则**

  - ```c++
    class Test{
         public:
             virtual int test(int m){return m;}
         private:
             int a;
            char b;
             char* c;
     };
     
     struct p1{
         int i;
         char* j;
         char m;
     };
     
     int main()
     {
         Test A;
         cout<<sizeof(A)<<endl;  //填充后为24字节,按偏移量计算填充
         p1 p;
         cout<<sizeof(p)<<endl;  //填充后为24字节，按偏移量计算填充
     }
    
    ```


### 3.10 在机器级程序中将控制与数据结合起来

- 理解指针

  - void* 类型代表通用指针，malloc返回一个通用指针

  - 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值

  - 函数指针:  函数指针的值是该函数机器代码表示中第一条指令的地址　　int  (*fp) (int,int\* )    fp为函数指针

  - ```c++
    int  (*fp) (int,int* )   // fp为函数指针  ()是必须的
    int *f(int *) //f是一个函数
    ```

  

- 使用GDB调试器
  - gdb prog 调试prog程序
  - quit run   kill
  - break   delete
  - stepi    nexti   continue  finish
  - disas
  - info frame
  - info registers
  - help
  - DDD,GDB的扩展，提供了图形界面
- 内存越界引用和缓冲区溢出
- 对抗缓冲区溢出攻击
  - 栈随机化
  - 栈破坏检测
  - 限制可执行代码区域
- 支持变长栈帧