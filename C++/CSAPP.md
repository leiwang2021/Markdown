# CSAPP

## 第一章　计算机系统漫游

### 1.1 信息就是位+上下文

- 源程序是由值0和1组成的位序列，字节序列
- 只由ASCII字符构成的文件称为文本文件，所有其他文件都称为二进制文件

### 1.2 程序被其他程序翻译成不同的格式

- gcc -o hello  hello.c
- 编译系统
  - 预处理器(cpp) 读取系统头文件插入到程序文本中，得到修改了的源程序 hello.i

  - 编译器(ccl)将文本文件hello.i 翻译成hello.s  包含一个汇编语言程序,包含函数main的定义

  - 汇编器(as)将hello.s翻译成机器语言指令，得到可重定位目标程序的二进制文件hello.o

  - 链接器(ld)合并hello.o和printf函数的printf.o目标文件，得到可执行目标文件hello,可被加载到内存中，由系统执行

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-04-24.png)

### 1.3 编译系统

- 优化程序性能
- 理解链接时出现的错误
- 避免安全漏洞，缓冲区溢出错误是造成大多数网络安全漏洞的主要原因

### 1.4 处理器读取并解释存储在内存中的指令

- 系统的硬件组成
  - 总线：总线被设计成传送定长的字节块
  - I/O设备
  - 主存，临时存储设备，用于存放程序和程序处理的数据，DRAM
  - 处理器，执行存储在主存中指令的引擎
- 运行hello程序
  - 代码和数据从磁盘复制到主存，再从主存复制到寄存器，再从寄存器文件中复制到显示设备

### 1.5　高速缓存

- 高速缓存存储器存放经常访问的数据，提高访问速度　　SRAM

- 在处理器和主存之间插入一个高速缓存可以提高速度

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-05-12.png)

### 1.6 存储设备层次结构

- 上一层的存储器作为低一层存储器的高速缓存

- 可以利用对整个存储器层次结构的理解提高程序性能

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-05-36.png)

### 1.7 操作系统管理软件

- 所有应用程序对硬件的操作尝试都必须通过操作系统

  ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-06-02.png)

- 操作系统两个基本功能
  - 防止硬件被失控的应用程序滥用
  - 向应用程序提供简单一致的机制来控制复杂的硬件设备

- 操作系统通过基本的抽象概念(进程、虚拟内存和文件)实现
  - 文件是对I/O设备的抽象表示
  - 虚拟内存是对主存和磁盘I/O设备的抽象表示
  - 进程是对处理器、主存和I/O设备的抽象表示

- 进程

  - 进程是操作系统对一个正在运行的程序的一种抽象
  - 并发运行: 一个进程的指令和另一个进程的指令是交错执行的
  - 上下文:跟踪进程运行所需的所有状态信息
  - 上下文切换: 切换进程
  - 从一个进程到另一个进程的转换是操作系统内核管理的，内核是操作系统代码常驻主存的部分，内核是系统管理全部进程所用代码和数据结构的集合

- 线程

  - 一个进程实际上可以由多个线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和数据

- 虚拟内存

  - 为每个进程提供一个假象，即每个进程都独占地使用主存

  - 每个进程看到的内存都是一样的，称为虚拟地址空间

  - 程序代码和数据

  - 堆: 在运行时可动态扩展和收缩

  - 共享库: 存放像C标准库的代码和数据

  - 栈: 编译器用它来实现函数调用

  - 基本思想是把一个进程虚拟内存的内容存储在磁盘上，用主存作为磁盘的高速缓存

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-00-57.png)

- 文件
  - 文件就是字节序列，每个I/O设备都可看成文件
  - 系统中的所有输入输出都是通过Unix I/O的系统函数调用读写文件来实现的

### 1.8 系统之间利用网络通信

- 系统从主存复制一串字节到网络适配器，数据流过网络到达另一台机器

### 1.9

- Amdahl定律，想要显著加速整个系统，必须提升全系统中相当大的部分的速度

- 并发: 一个同时具有多个活动的系统

- 并行: 用并发来使一个系统运行得更快

- 线程级并发

  - 多处理器系统

  - 超线程: 同时多线程，允许一个CPU执行多个控制流的技术

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-22-44.png)

- 指令级并发

  - 同时执行多条指令
  - 若处理器可以达到比一个周期一条指令更快的执行速率，就称为超标量处理器

- 单指令、多数据并发

  - 一条指令可以产生多个可以并行执行的操作

    ![](/home/leiwang/Markdown/C++/picture/Screenshot from 2019-09-04 16-35-39.png)

## 第2章　信息的表示和处理

### 2.1 信息存储

- 大多数计算机使用8位的块，即字节作为最小的可寻址的内存单元
- 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存，内存的每一个字节都由一个唯一数字标识，称为地址，地址的集合称为虚拟地址空间
- 字长: 指明指针数据的标称大小，决定虚拟地址空间的最大大小，64位机器可以运行32位机器编译的程序
- 32位程序和64位程序，区别在于程序是如何编译的，而不是其运行的机器类型
- 指针在Win32下的大小为4字节，x64下的大小为8字节
- 寻址和字节顺序
  - 多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址
  - 字节顺序: 从高位地址还是从低位地址存储
  - 小端法和大端法，与机器有关，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则
  - sizeof(T) 返回存在一个类型为T的对象所需要的字节数
  - man ascii可得到一张ASCII字符码的表
- Unicode标准
  - UTF-8表示将每个字符编码为一个字节序列
  - 所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的
- 表示代码
  - 即使完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的，二进制代码很少能在不同的机器和操作系统组合之间移植
  - 程序仅仅只是字节序列
- 布尔代数:  用位向量对集合进行编码
- 逻辑运算和位运算
  - &&       &
  - ||        |
- 移位运算
  - 逻辑右移：左端补k个0
  - 算术右移: 左端补k个最高有效位的值
  - 对于有符号数，默认使用算术右移，对于无符号数，逻辑右移

### 2.2 整数表示

- 无符号数的编码
- 补码编码表示有符号整数
  - 最高有效位为符号位
  - 最小值为10000000000...
  - 最大值为01111111111...
- 有符号数和无符号数之间的转换
  - 强制类型转换的结果保持位值不变，只是改变了解释这些位的方式
- C语言中的有符号数和无符号数
  - 一个有符号数和无符号数运算，隐式地将有符号数强制转换为无符号数
- 扩展一个数字的位表示
- 截断数字
- 有符号数到无符号数的隐式类型转换可能会导致程序错误

### 2.3 整数运算

- 无符号加法
  - 可能会溢出
- 补码加法
- 补码的非
- 无符号乘法
- 补码乘法
- 乘以常数
- 除以2的幂

### 2.4 浮点数

- 二进制小数
- IEEE浮点表示
  - 符号
  - 尾数
  - 阶码
- 舍入
- 浮点运算

### 2.5 总结

- 64位程序的优势是可以突破32位程序具有的4GB地址限制
- 大多数机器对整数使用补码编码，而对浮点数使用IEEE标准754编码
- 使用位级运算和算术运算组合的方法



## 第三章　程序的机器级表示

- 历史观点

  - 8086　第一代单芯片、16位微处理器之一

  - Intel处理器系列，即x86
  - IA32, Intel 32位体系结构
  - x86-64 Intel64位体系结构

### 3.2 程序编码

  - linux  gcc  -Og -o p p1.c p2.c

  - gcc指GCC C编译器，是Linux上默认的编译器，编译选项 -Og生成符合原始C代码整体结构的机器代码的优化等级。

  - 首先，C预处理器扩展源代码，插入头文件代码，扩展宏；其次，编译器产生两个源文件的汇编代码，分别为p1.s和p2.s；接下来，汇编器将汇编代码转成二进制目标代码文件p1.o p2.o，目标代码是机器代码的一种形式，包含所有指令的二进制表示。最后，链接器将两个目标代码文件与实现库函数的代码合并，并产生最终的可执行代码文件p(由命令行选项-o p指定)

  - 机器级代码

    - 指令体系结构或指令集架构(ISA)定义机器级程序的格式和行为

    - 程序内存包括:  程序的可执行机器代码、操作系统需要的一些信息、用来管理过程调用、返回的运行时栈、用户分配的内存块

    - -S选项可看到C编译器产生的汇编代码　　gcc -Og -S  p1.c　　生成p1.s

    - gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。
      后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。
      编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。

    - -c命令行选项，GCC会编译并汇编该代码  生成p1.o 二进制格式

    - 如何展示程序的字节表示: 

      - 用反汇编器确定代码长度为14
      - 运行GNU调试工具GDB     在文件mstore.o上运行GDB,然后  输入命令　(gdb) x/14xb multstore

    - 反汇编器

      - objdump  -d  mstore.o 
      - x86-64的指令长度从1到15个字节不等
      - 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码
      - 后缀q是是大小指示符

    - 生成实际可执行代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个main函数　　-o生成可执行文件

      - gcc -Og -o prog main.c mstore.c

      - 链接器的任务之一是为函数调用找到匹配的函数的可执行代码的位置
      - 最后可能会插入字节，使得能更好地存放下一个代码块

- 格式的注解

  - 以.开头的行都是指导汇编器和链接器工作的伪指令
  - 在C语言中插入汇编代码的方法
    - 用汇编代码编写整个函数，在链接阶段把它们和C函数组合起来
    - 或者利用GCC的支持，直接在C程序中嵌入汇编代码

### 3.3 数据格式