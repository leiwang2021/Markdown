# APUE

- 谷歌的Android采用Linux作为操作系统内核
- 系统调用接口和标准C库提供的许多函数



## 第一章　UNIX基础知识

### 1.1



### 1.2 UNIX体系结构

- 从严格意义上说，将操作系统称为内核，内核的接口被称为系统调用
- 从广义上说，操作系统包括了内核和系统实用程序、应用程序、shell以及公共函数库

### 1.3登录

- 登录名
- shell

### 1.4 文件和目录

- 文件系统
  - stat和fstat函数返回包含所有文件属性的一个信息结构
- 文件名
- 路径名
- 工作目录
  - chdir函数更改其工作目录

### 1.5 输入和输出

- 文件描述符

  - 当内核打开一个现有文件或创建一个新文件时，都会返回一个文件描述符，在读写文件时，可以使用这个文件描述符

- 标准输入、标准输出和标准错误

- 不带缓冲的I/O

  - 函数open  read  write  lseek以及close提供了不带缓冲的I/O,都使用文件描述符

  - 头文件<unistd.h>包含了很多UNIX系统服务的函数原型，如read和write

- 标准I/O

  - 提供了一个带缓冲的接口
  - 常量EOF和标准I/O常量stdin和stdout也在<stdio.h>中定义

### 1.6 程序和进程

- 程序，内核使用exec函数将程序读入内存，并执行程序
- 进程和进程ID
  - 程序的执行实例被称为进程
  - getpid得到进程ID
- 进程控制
  - 3个用于进程控制的主要函数: fork   exec  waitpid
  - fork对父进程返回新的子进程的进程ID,对子进程则返回0
- 线程和线程ID
  - 一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性，线程ID只在它所属的进程内起作用

### 1.7 出错处理

- 当Unix函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值
- 文件<errno.h>中定义了errno以及可以赋予它们的各种常量
- 两个出错函数　　strerror   perror
- 出错恢复



### 1.8 用户标识

- 用户ID
  - 用户ID为0的为root
  - 口令文件包含了登录名和用户ID之间的映射关系
- 组ID
  - 组文件通常是/etc/group
  - 组文件则包含了组名和组ID之间的映射关系
- getuid   getgid 返回用户ID和组ID



### 1.9 信号

- 忽略信号
- 按系统默认方式处理
- 提供一个函数，信号发生时调用该函数
- 为了能捕捉到信号，程序需要调用signal函数



### 1.10 时间值

- 日历时间　time_t
- 进程时间　clock_t
- 时钟时间
- 用户CPU时间
- 系统CPU时间
- time
- cd   /usr/include        time -p grep _POSIX_SOURCE */*.h   展示三种时间



### 1.11 系统调用和库函数

- 各种版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用
- 通用库函数可能会调用一个或多个内核的系统调用，但是它们并不是内核的入口点
- 应用程序既可以调用系统调用也可以调用库函数，很多库函数则会调用系统调用



## 第二章　UNIX标准及实现

### 2.1 

### 2.2 UNIX标准化

- ISO C
  - ISO C头文件依赖于操作系统所配置的C编译器的版本
  - 可将ISO C库分成24个区
- IEEE POSIX
  - POSIX指可移植操作系统接口
  - POSIX.1包含了ISO C标准库函数
- Single UNIX Specification
  - POSIX.1相当于Single UNIX Specification中的基本规范部分
  - 只有遵循XSI的实现才能称为UNIX系统

### 2.3 UNIX系统实现

- SVR4
- 4.4BSD
- FreeBSD
- Linux
- Mac OS X
- Solaris
- 其他UNIX系统

### 2.4 标准和实现的关系

- 各个标准定义了任一实际系统的子集



### 2.5 限制

- 编译时限制，可以在头文件里定义
- 运行时限制，要求进程调用一个函数获得限制值

  - 与文件或目录无关的运行时限制(sysconf函数)
  - 与文件或目录有关的运行时限制(pathconf函数和fpathconf函数)
- ISO C限制

  - 定义的所有编译时限制都定义在头文件<limits.h>
  - 头文件<float.h>也有类似的定义
  - FOPEN_MAX,在<stdio.h>中，具体实现保证可同时打开的标准I/O流的最小个数
  - TMP_MAX
  - FILENAME_MAX
- POSIX限制

  - 定义在<limits.h>中

  - 数值限制
  - 最小值
  - 最大值运行时可以增加的值
  - 运行时不变值
  - 其他不变值
  - 路径名可变值
  - sysconf, pathconf, fpathconf使用这三个函数可以在运行时得到实际的实现值
- XSI限制
- 函数sysconf, pathconf, fpathconf

  - awk
- 不确定的运行时限制
  - 路径名
  - 最大打开文件数



### 2.6 选项

- 需要一种可移植的方法来判断实现是否支持一个给定的选项
- 三种处理选项的方法
  - 编译时选项定义在<unistd.h>
  - sysconf
  - pathconf
  - fpathconf

### 2.7 功能测试宏

- 一旦定义了_POSIX_C_SOURCE，所有POSIX.1头文件都使用此常量来排除任何实现专有的定义
- cc -D _POSIX_C_SOURCE=200809L file.c      使得C程序在任何头文件之前，定义了功能测试宏



### 2.8 基本系统数据类型

- 头文件<sys/types.h>中定义了某些与实现有关的数据类型



### 2.9 标准之间的冲突



## 第三章　文件I/O

### 3.1 引言

- open  read  write  lseek  close
- 不带缓冲指的是每个read和write都调用内核中的一个系统调用
- 在多个进程间共享资源

### 3.2 文件描述符

- 所有打开的文件都通过文件描述符引用
- 常量STDIN_FILENO   STDOUT_FILENO   STDERR_FILENO  在头文件<unistd.h>中定义

### 3.3 函数open和openat

- #include<fcnt1.h>

- 由open和openat函数返回的文件描述符一定是最小的未用描述符数值
- 同一进程中的所有线程共享相同的当前工作目录
- TOCTTOU错误
- 文件名和路劲截断

### 3.4 函数creat

- #include<fcnt1.h>

- 可调用creat函数创建一个新文件

### 3.5 函数close

- #include<unistd.h>
- 可调用close函数关闭一个打开文件
- 关闭一个文件还会释放该进程加在该文件上的所有记录锁
- 当一个进程终止时，内核自动关闭它所有的打开文件

### 3.6 函数lseek

- 每个打开文件都有一个与其相关联的当前文件偏移量，用以度量从文件开始处计算的字节数
- 可以调用lseek显式地为一个打开文件设置偏移量
- #include<unistd.h>
- 若lseek成功执行，则返回新的文件偏移量
- 如果文件描述符指向的是一个管道、FIFO或网络套接字，则lseek返回-1,并将errno设置为ESPIPE
- 某些设备也可允许负的偏移量
- 文件偏移量可以大于文件的当前长度，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，空洞不要求在磁盘上占用存储区
- od命令
- od -c   filename 以字符方式打印文件内容
- off-t类型，具体实现根据各自特定的平台自行选择大小合适的数据类型

### 3.7 函数read

- 从打开文件中读数据
- 读操作从文件的当前偏移量处开始，在成功返回之前，该偏移量将增加实际读到的字节数
- #include<unistd.h>

### 3.8 函数write

- 调用write函数向打开文件写数据
- 其返回值通常与参数nbytes的值相同，否则表示出错

### 3.9 I/O的效率

### 3.10 文件共享

- 在不同进程间共享打开文件
- 内核使用3种数据结构表示打开文件
  - 进程表项
  - 文件表项
    - 可能有多个文件描述符指向同一文件表项
  - v节点表项
    - 创建v节点结构的目的是对在一个计算机系统上的多文件系统类型提供支持
    - 打开该文件的每个进程都获得各自的一个文件表项，但对于一个给定的文件只有一个v节点表项

### 3.11 原子操作

- 追加到一个文件

  - 任何要求多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核有可能会临时挂起进程

- 函数pread和pwrite

  - #include<unistd.h>
  - 调用pread相当于调用lseek后调用read

- 创建一个文件

- 一般而言，原子操作指的是由多步组成的一个操作，如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集

### 3.12 函数dup和dup2

- 可用来复制一个现有的文件描述符
- 这些函数返回的新文件描述符与参数fd共享同一个文件表项
- 每个文件描述符都有它自己的一套文件描述标志

### 3.13 函数sync, fsync, fdatasync

- 当我们向文件写入数据时，内核通常先将数据复制到缓冲区，然后排入队列，晚些时候再写入磁盘，这种方式称为延迟写
- #include<unistd.h>
- sync只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束
- fsync函数只对由文件描述符指定的一个文件起作用，并且等待写磁盘操作结束才返回
- fdatasync函数类似与fsync,但它只影响文件的数据部分



### 3.14 函数fcnt1

- fcnt1函数可以改变已经打开文件的属性
- #include<fcnt1.h>
- F_DUPFD　复制文件描述符fd
- F_DUPFD_CLOEXEC
- F_GETFD
- F_SETFD
  - 当前只定义了一个文件描述符标志　　FD_CLOEXEC
- F_GETFL
- F_SETFL
- F_GETOWN
- F_SETOWN
- 子句5<>temp.foo表示在文件描述符5上打开文件temp.foo以供读写
- 在UNIX系统中，通常write只是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。开启同步写标志，直至数据已写到磁盘上再返回
- 同步写和延迟写

### 3.15 函数ioct1

- #include<sys/ioct1.h>
- 每个设备驱动程序可以定义自己专用的一组ioct1命令，系统则为不同种类的设备提供通用的ioct1命令



### 3.16 /dev/fd

- /dev/fd/n
- 打开/dev/fd/n文件等效于复制描述符n ,   但在Linux系统中，Linux实现使用指向实际文件的符号链接，不一样

## 第四章　文件和目录

### 4.1

### 4.2 函数stat fstat fstatat lstat

- #include<sys/stat.h>
-  struct stat



### 4.3 文件类型

- 普通文件
- 目录文件，只有内核可以直接写目录文件
- 块设备文件　这种类型的文件提供对设备(如磁盘)带缓冲的访问，每次访问以固定长度为单位进行
- 字符特殊文件，　这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变
- FIFO　用于进程间通信，也称为命令管道
- 套接字　用于进程间的网络通信
- 符号链接　这种类型的文件指向另一个文件
- 文件类型信息包含在stat结构的st_mode成员中
- S_ISxxx宏

### 4.4 设置用户ID和设置组ID

- ID
  - 实际用户ID
  - 实际组ID
  - 有效用户ID
  - 有效组ID
  - 附属组ID
  - 保存的设置用户ID  保存在文件的st_mode值中
  - 保存的设置组ID　　保存在文件的st_mode值中

### 4.5 文件访问权限

- st_mode值也包含了对文件的访问权限位，9个访问权限位
- 如果当前目录是/usr/include,那么为了打开文件stdio.h, 需要对当前目录有执行权限，对该目录的执行权限使我们可搜索该目录
- 用exec函数执行任何一个文件，该文件需具有执行权限，该文件还必须是一个普通文件
- 两个所有者ID是文件的性质，而两个有效ID和附属组ID则是进程的性质

### 4.6 新文件和目录的所有权

- 新文件的用户ID设置为进程的有效用户ID
- 新文件的组ID



### 4.7 函数access和faccessat

- 按实际用户ID和实际组ID进行访问权限测试的
- #include<unistd.h>
- 当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试

### 4.8 函数umask

- umask函数为进程设置文件模式创建屏蔽字，并返回之前的值
- 在文件模式创建屏蔽字中为1的位，在文件mode中的相应位一定会被关闭
- 更改进程的文件模式创建屏蔽字并不影响父进程的屏蔽字

### 4.9 函数chmod fchmod 和fchmodat

- 更改现有文件的访问权限

### 4.10 粘着位

- 如果可执行程序文件的这一位被设置了。那么当程序第一次被执行，在其终止时，程序正文部分的一个副本仍被保存在交换区
- 如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并满足下列条件之一，才能删除或重命名该目录下的文件

### 4.11 函数chown  fchown  fchownat lchown

- 可用于改变文件的用户ID和组ID
- #include<unistd.h>

### 4.12 文件长度

- stat结构成员st_size表示以字节为单位的文件的长度
- 文件中的空洞
  - wc -c   计算文件中的字节数
  - 文件系统使用了若干块以存放指向实际数据块的各个指针

### 4.13 文件截断

- truncate
- ftruncate  将一个现有文件长度截断为length

### 4.14 文件系统

- 硬链接
  - 每个i结点都有一个链接计数，其值是指向该i结点的目录项数
- 符号链接
  - 符号链接文件的实际内容(在数据块中)包含了该符号链接所指向的文件的名字
- i节点包含了文件有关的所有信息，只有文件名和i节点编号存放在目录项中
- 为一个文件重命名时，只需构造一个指向现有i节点的新目录项
- 链接计数大于或等于3表明至少有3个目录项指向它

### 4.15 函数link  linkat unlink  unlinkat  remove 

- 任何一个文件可以有多个目录项指向其i节点，创建一个指向现有文件的链接的方法是使用link函数或linkat函数
- 创建新目录项和增加链接计数应当是一个原子操作
- 很多文件系统实现不允许对于目录的硬链接
- 为了删除一个现有的目录项，可以调用unlink函数
- 关闭一个文件时，内核首先检查打开该文件的进程个数，如果这个计数达到0,内核再去检查其链接计数，如果计数也是０，那么删除该文件的内容
- remove可以解除对一个文件或目录的链接

### 4.16 函数rename和renameat

- 文件或目录可以用rename函数或者renameat函数进行重命名

- #include<stdio.h>

### 4.17 符号链接

- 硬链接直接指向文件的i节点
- 对符号链接以及它指向何种对象并无任何文件系统限制
- 使用符号链接可能在文件系统中引入循环
- 各个函数是否处理符号链接?

### 4.18 创建和读取符号链接

- symlink    symlinkat函数创建一个符号链接
- 不需要位于同一文件系统中
- readlink  readlinkat 打开该链接本身，并读取该链接中的名字

### 4.19 文件的时间

- st_atim 文件数据的最后访问时间       ls   -u
- st_mtim  文件数据的最后修改时间
- st_ctim   i节点状态的最后更改时间    ls  -c
- i节点中的所有信息都是与文件的实际内容分开存放的
- 目录是包含目录项(文件名和相关的i节点编号)的文件

### 4.20 函数futimens  utimensat  utimes

- 访问和修改时间的更改

### 4.21 函数mkdir mkdirat  rmdir

- 用mkdir  mkdirat函数创建目录　　.和..目录自动创建
- 用rmdir函数删除目录，可以删除一个空目录，只包含.和..这两项的目录

### 4.22 读目录

- opendir  fdopendir函数
- readdir
- rewinddir
- closedir
- telldir和seekdir
- #include<dirent.h>

### 4.23 函数chdir fchdir getcwd

- 每个进程都有一个当前工作目录
- 进程调用chdir或fchdir函数可以更改当前工作目录
- getcwd

### 4.24 设备特殊文件

- 每个文件系统所在的存储设备都由其主、次设备号表示，主设备号标识设备驱动程序，次设备号标识特定的子设备，同一磁盘驱动器上的各文件系统通常具有相同的主设备号，但是次设备号却不同
- st_dev值是文件系统的设备号
- st_rdev包含实际设备的设备号

## 第五章　标准I/O库

### 5.2 流和FILE对象

- 对于标准I/O库，它们的操作都是围绕流进行的
- 流的定向决定了所读、所写的字符是单字节还是多字节的
- fwide函数设置流的定向
- 标准I/O函数返回一个指向FILE对象的指针，该对象通常是一个结构

### 5.3 标准输入、标准输出和标准错误

- 对一个进程预定义了3个流，这3个标准I/O流通过预定义指针stdin stdout stderr加以引用



### 5.4 缓冲

- 标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数
- 全缓冲，在填满标准I/O缓冲区后才进行实际I/O操作
- 行缓冲，遇到换行字符时，执行I/O操作
- 不带缓冲，标准错误流通常是不带缓冲的
- setbuf 函数打开或关闭缓冲机制
- setvbuf
- fflush 使该流所有未写的数据都被传送到内核

### 5.5 打开流

- fopen函数打开一个指定的文件
- freopen函数在一个指定的流上打开一个指定的文件
- fdopen函数取一个已有的文件描述符，并使一个标准的I/O流与该描述符相结合

### 5.6 读和写流

- 输入函数
  - getc
  - fgetc
  - getchar
  - 可用于一次读一个字符
- 出错标志和文件结束标志
  - ferror
  - feof
  - 为每个流在FILE对象中维护了两个标志
  - clearerr可以清除这两个标志
- ungetc将字符再压送回流中
- 输出函数
  - putc
  - fputc
  - putchar

### 5.7 每次一行I/O

- fgets
- gets
- fputs
- puts

### 5.8 标准I/O的效率

- exit函数将会冲洗任何未写的数据，然后关闭所有打开的流
- 系统调用与普通的函数调用相比需要花费更多的时间

### 5.9 二进制I/O

- fread
- fwrite
- 使用二进制I/O的基本问题是: 它只能用于读在同一个系统上已写的数据

### 5.10 定位流

- ftell
- fseek
- ftello
- fseeko
- fgetpos
- fsetpos

### 5.11 格式化I/O

- 格式化输出
  - printf
  - fprintf
  - dprintf
  - sprintf
  - snprintf
  - 转换说明以百分号%开始
- 格式化输入
  - scanf
  - fscanf
  - sscanf

### 5.12 实现细节

- 在UNIX中，标准I/O库最终都要调用第3章说明的I/O例程，每个标准I/O流都有一个与其关联的文件描述符，可以对一个流调用fileno函数获得其描述符
- 标准错误是不带缓冲的，普通文件按系统默认是全缓冲的

### 5.13 临时文件

- tmpnam  产生一个有效路径名字符串
- tmpfile　创建一个临时二进制文件，在关闭文件或程序结束时将自动删除这种文件
- mkdtemp 和mkstemp  创建目录和文件，　mkstemp创建的临时文件并不会自动删除，必须自己对它解除链接
- 把指针自身驻留在栈上，但指向的常量字符串存放在可执行文件的只读段，当试图修改字符串时，会出现段错误(segment fault)

### 5.14 内存流

- 标准I/O库把数据缓存在内存中
- fmemopen 用于内存流的创建
- open_memstream 函数创建的流是面向字节的
- open_wmemstream函数创建的流是面向宽字节的
- 避免了缓冲区溢出，内存流非常适用于创建字符串
- 内存流只访问主存，不访问磁盘上的文件



## 第六章　系统数据文件和信息

## 6.2 口令文件

- <pwd.h>中定义的passwd结构
- 口令文件ｓ/etc/passwd ,而且是一个ASCII文件
- root用户ID是0, 加密口令字段包含一个占位符
- finger命令　finger -p leiwang　　　　　 The finger displays information about the system users.
- getpwuid
- getpwnam
- passwd结构通常是函数内部的静态变量
- getpwent 返回口令文件中的下一个记录项
- setpwent
- endpwent

## 第七章　进程环境

### 7.2 main函数

- main函数的原型　int main(int argc, char* argv[]);
- 在调用main函数前先调用一个特殊的启动例程，启动例程从内核取得命令行参数和环境变量值

### 7.3 进程终止

- 8种方式使进程终止
  - 从main返回
  - 调用exit
  - 调用_exit或\_Exit
  - 最后一个线程从其启动例程返回
  - 从最后一个线程调用pthread_exit
  - 调用abort
  - 接到一个信号
  - 最后一个线程对取消请求做出响应
- 退出函数
  - \_exit 和\_Exit立即进入内核
  - exit先执行一些清理处理，
  - 然后返回内核
  - 终止状态
  - **ｍain函数返回一个整型值与用该值调用exit是等价的**
- 函数atexit
  - 一个进程可以登记多至32个函数，这些函数将由exit自动调用，终止处理程序
  - exit首先调用各终止处理程序，然后关闭所有打开流
  - 内核使程序执行的唯一方法是调用一个exec函数，进程自愿终止的唯一方法是显式或隐式地(通过调用exit)调用_exit或\_Exit。进程也可以非自愿地由一个信号使其终止

### 7.4 命令行参数

### 7.5 环境表

- 每个程序都接收到一张环境表
- 环境表是一个字符指针数组，全局变量environ包含了该指针数组的地址
- extern char **environ

### 7.6 C程序的存储空间布局

- 正文段，由CPU执行的机器指令部分
- 初始化数据段
- 未初始化数据段
- 栈
- 堆
- a.out还有若干其他类型的段，包含符号表的段、包含调试信息的段以及包含动态共享库链接表的段等，这些部分并不装载到进程执行的程序映像中
- 未初始化数据段的内容并不存放在磁盘程序文件中，内核在程序开始运行前将它们都设置为0,需要存放在磁盘程序文件中的段只有正文段和初始化数据段
- size命令报告正文段、数据段和bss段的长度　　size a.out

### 7.7 共享库

- 共享库使得可执行文件中不再需要包含公用的库函数，而只需要在所有进程都可引用的存储区中保存这种库例程的一个副本
- 共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编译
- gcc -static hello.c  不使用共享库的方式
- gcc hello.c  使用共享库的方式

### 7.8 存储空间分配

- 3个用于存储空间动态分配的函数
  - malloc,分配指定字节数的存储区，此存储区的初始值不确定
  - calloc 为指定数量指定长度的对象分配存储空间，该空间中的每一位都初始化为0
  - realloc 增加或减少以前分配区的长度，当增加长度时，可能需要将以前分配区的内容移到另一个足够大的区域，新曾区域初始值不确定
  - 这三个函数返回的指针一定是适当对齐的
  - free
- 替代的存储空间分配程序

### 7.9 环境变量

- getenv 取环境变量值
- putenv　可自由地将传递给它的字符串直接放到环境中
- setenv  必须分配存储空间
- unsetenv　
- 环境表和环境字符串通常存放在进程存储空间的顶部(栈之上)

### 7.11 函数setjmp和longjmp

- 对于处理发生在很深层次嵌套函数调用中的出错情况是非常有用的，在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中
- C语言中，goto语言是不能跨越函数的
- 在希望返回的位置调用setjmp,参数env的类型是一个特殊类型jmp_buf
- 自动变量、寄存器变量和易失变量
  - 定义为volatile属性的自动变量，其值不回滚
  - 全局变量或静态变量的值在执行longjmp时保存不变
  - gcc testjmp.c  不进行任何优化的编译　所有这5个变量都存放在存储器中
  -  gcc -O testjmp.c 　进行全部优化的编译， autoval和regival都存放在寄存器中，volatile变量仍存放在存储器中
  - 全局变量、静态变量和易失变量不受优化的影响，在longjmp之后，它们的值是最近的值
  - 存放在存储器中的变量将具有longjmp时的值，而在CPU和浮点寄存器中的变量则恢复为调用setjmp时的值

### 7.11 函数getrlimit和setrlimit

- 资源限制的查询和更改
- 资源限制影响到调用进程并由其子进程继承
- 字符串创建算符(#)  #define doit(name)  pr_limits(#name, name)
- warning: ISO C++ forbids converting a string constant to ‘char*’ [-Wwrite-strings]
   #define doit(name) pr_limits(#name, name)       g++编译时
- gcc编译时不会



## 第八章　进程控制

### 8.2 进程标识

- ID为0的进程通常是调度进程，称为交换进程，是内核的一部分
- 进程ID1通常是init进程，在自举过程结束时由内核调用，此进程负责在自举内核后启动一个Unix系统，init通常读取与系统有关的初始化文件，并将系统引导到一个状态。init进程决不会终止，它是一个普通的用户进程，但它是以超级用户特权运行
- 每个Unix系统实现都有它自己的一套供操作系统服务的内核进程
- getpid
- getppid
- getuid
- geteuid
- getgid
- getegid

### 8.3 函数fork

- 一个现有的进程可以调用fork函数创建一个新进程。子进程返回0,父进程返回子进程ID
- 由fork创建的新进程被称为子进程，fork函数被调用一次，但返回两次，两次返回的区别是子进程的返回值是0,而父进程的返回值是新建子进程的进程ID
- 子进程是父进程的副本，子进程获得父进程数据空间，堆和栈的副本，这是子进程所拥有的副本，父进程和子进程并不共享这些存储空间，共享正文段
- 写时复制技术(COW)
- 在fork之后是父进程还是子进程先执行是不确定的，取决于内核所使用的调度算法。如果要求父进程和子进程互相同步，则要求某种形式的进程间通信
- strlen计算不包含终止null字节的字符串长度，而sizeof则计算包括终止null字节的缓冲区长度
- 标准输出缓冲区可以由换行符冲洗
- 文件共享
- fork的特性是父进程的所有打开文件描述符都被复制到子进程中，父进程和子进程共享同一个文件偏移量
- 父进程和子进程的共同与不同点

### 8.4 函数vfork

- vfork函数的调用序列和返回值与fork相同，但两者的语义不同
- 创建一个子进程，但是它不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit
- vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行



### 8.5 函数exit

- 不管进程如何终止，最后都会执行内核中的同一段代码，这段代码为相应进程关闭所有打开文件描述符，释放它所使用的存储器

- 对于父进程已经终止的所有进程，它们的父进程都改变为init进程，称这些进程由init进程收养

- 内核为每个终止子进程保存了一定量的信息

- 一个已经终止、但是其父进程尚未对其进行善后处理(获取终止进程的有关信息，释放它所占用的资源)的进程被称为僵死进程

- ps将僵死进程的状态打印为Z

- init被编写成无论何时只要有一个子进程终止，init就会调用一个wait函数取得其终止状态，防止了在系统中塞满僵死进程




### 8.6 函数wait和waitpid

- 当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号
- 调用wait或waitpid的进程
  - 如果其所有子进程都还在运行，则阻塞
  - 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回
  - 如果它没有任何子进程，则立即出错返回
- wait和waitpid所返回的终止状态的宏
- waitpid等待一个特定进程的函数，wait返回任一终止子进程的状态
- waitpid提供了一个wait的非阻塞版本
- 在fork之后，父进程和子进程都可继续执行，并且我们无法预知哪一个会先执行



### 8.7 函数waitid

- 类似于waitpid

### 8.8 函数wait3和wait4

- 允许内核返回由终止进程及其所有子进程使用的资源概况

### 8.9 竞争条件

- 如果一个进程希望等待一个子进程终止，则它必须调用wait函数中的一个，如果一个进程要等待其父进程终止，则可使用下列形式的循环

  ```c++
  while(getppid()!=1)
  	sleep(1);
  ```

- 为了避免竞争条件和轮询，在多个进程之间需要有某种形式的信号发送和接收的方法，在Unix中可以使用信号机制，各种形式的进程间通信也可以使用

- 在程序中将标准输出设置为不带缓冲的，于是每个字符输出都需要调用一次write

### 8.10 函数exec

- 当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序从main函数开始执行，exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段
- 7个不同的exec函数
  - execl
  - execv
  - execle
  - execve
  - execlp
  - execvp
  - fexecve
- 三个区别
- 字母p表示该函数取filename作为参数，并且用PATH环境变量寻找可执行文件，字母l表示该函数取一个参数表，v表示取一个argv[]矢量，字母e表示取envp[]数组，而不使用当前环境

- 执行exec后，新程序从调用进程继承了一些属性
- 只有execve是内核的系统调用，另外6个只是库函数，它们最终都要调用该系统调用

### 8.11 更改用户ID和更改组ID

- 最小特权模型
- setuid
- setgid
- setuid
- setgid

### 8.12 解释器文件

- #! pathname [option-argument]
- 最常见的解释器文件
- /bin/sh
- 对于这种文件的识别是由内核作为exec系统调用处理的一部分完成的，内核使调用exec函数的进程实际执行的并不是该解释器文件，而是该解释器文件第一行中pathname所指定的文件

### 8.13 函数system

- system在其实现中调用了fork exec waitpid
- int system(const char* cmdstring)
- execl("/bin/sh","sh","-c",cmdstring,(char*)0);
- shell的-c选项告诉shell程序取下一个命令行参数作为命令输入
- 调用_exit而不是exit, 这是为了防止任一标准I/O缓冲(这些缓冲会在fork中由父进程复制到子进程)在子进程被冲洗
- 如　system("date")
- 使用system而不是直接使用fork和exec的优点是：system进行了所需的各种出错处理以及各种信号处理
- 设置用户ID程序
- system调用shell对命令字符串进行语法分析



### 8.14 进程会计

- Unix系统提供了一个选项以进行进程会计处理，启用该处理后，每当进程结束时内核就写一个会计记录
- 会计记录所需的各个数据都由内核保存在进程表中
- accton命令　

### 8.15 用户标识

- getlogin获取登录名



### 8.16 进程调度

- 进程可以通过调整nice值选择以更低优先级运行，只有特权进程允许提高调度权限
- nice值越小，优先级越高
- NZERO是系统默认的nice值
- nice函数，可以获取或更改nice值
- getpriority函数获取进程的nice值
- setpriority函数可用于为进程、进程组和属于特定用户ID的所有进程设置优先级



### 8.17 进程时间

- 墙上时钟时间、用户CPU时间、系统CPU时间
- times函数　返回墙上时钟时间作为其函数值



## 第九章　进程关系

### 9.2 终端登录

- BSD终端登录
  - 当系统自举时，内核创建进程ID为1的进程，init进程使系统进入多用户模式，init读取文件/etc/ttys,对每一个允许登录的终端设备，init调用一次fork,生成的子进程则exec getty程序，之后再exec login程序
  - 调用登录shell   exec("/bin/sh","-sh",(char*)0);
  - 登录shell读取启动文件(如.bash_profile)
- Linux终端登录
  - 类似于BSD
  - 使用存放在/etc/init目录的*.conf命名的配置文件，例如，运行/dev/tty1上的getty需要的说明可能放在/etc/init/tty1.conf文件中
- Solaris登录

### 9.3 网络登录

- 伪终端
- BSD网络登录
  - init调用一个shell,使其执行shell脚本/etc/rc,由此shell脚本启动一个守护进程inetd, 一旦此shell脚本终止，inetd的父进程就变成init,inetd等待TCP/IP连接请求，当一个连接到达时，执行一次fork,子进程exec适当的程序
  - telnetd进程打开一个伪终端设备，并用fork分成两个进程，父进程处理通过网络进行的通信，子进程执行login程序

### 9.4 进程组

- 每个进程除了有一个进程ID,还有一个进程组，其中的进程是在同一作业中结合起来的
- getpgrp 返回调用进程的进程组ID
- getpgid(0)　也返回进程的进程组ID
- 每个进程组有一个组长进程，组长进程的进程组ID等于其进程ID
- setpgid



### 9.5 会话

- 会话是一个或多个进程组的集合
- 通常是由shell的管道将几个进程编成一组的
  - 例如　proc1 | proc2
- 进程调用setsid 建立一个新会话，会话首进程总是一个进程组的组长进程，getsid函数返回会话首进程的进程组ID

### 9.6 控制终端

- 一个会话可以有一个控制终端，通常是终端设备或伪终端设备

- 建立与控制终端连接的会话首进程被称为控制进程

- 如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组

- 键入终端的中断键，会将中断信号发送至前台进程组的所有进程

- open文件/dev/tty ,在内核中，此特殊文件是控制终端的同语义，如果程序没有控制终端，则open会失败

### 9.7 函数tcgetpgrp tcsetpgrp tcgetsid

- tcgetpgrp返回前台进程组ID,它与在fd上打开的终端相关联
- 进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid, fd必须引用该会话的控制终端
- tcgetsid获得会话首进程的进程组ID

### 9.8 作业控制

- 一个作业只是几个进程的集合，通常是一个进程管道
  - 例如　vi main.c 在前台启动了只有一个进程组成的作业
  - pr*.c | lpr & 在后台启动了一个作业
- 只有前台作业接收终端输入，如果后台作业试图读终端，终端驱动程序检测到这种情况，向后台作业发送一个特定的信号SIGTTIN

### 9.9 shell执行程序

- ps -o pid,ppid,pgid,sid,tpgid,comm  TPGID指示前台进程组
- 注意: 使用的shell不同，创建各个进程的顺序也可能不同

### 9.10 孤儿进程组

- 孤儿进程组: 该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员

### 9.11 FreeBSD实现

- session结构
- proc结构　
- 控制终端vnode结构
- 控制终端tty结构
- pgrp结构
- vnode结构，在打开控制终端设备时分配此结构，进程对/dev/tty的所有访问都通过vnode结构



## 第10章　信号

- 信号是软件中断，提供了一种处理异步事件的方法

### 10.2 信号概念

- 信号名都被定义为正整数常量

- 产生信号

  - 用户按终端键时，产生的信号
  - 硬件异常产生的信号
  - kill
  - 软件条件产生的信号

- 信号的处理

  - 忽略此信号
  - 捕捉信号
  - 执行默认动作

- "终止+core"表示在进程当前工作目录的core文件中复制了该进程的内存映像，大多数UNIX系统调试程序都使用core文件检查进程终止时的状态

  - SIGABRT, 调用abort函数产生
  - SIGALRM, 当用alarm函数设置的定时器超时时产生
  - SIGBUS
  - SIGCANCEL
  - SIGCHLD
  - SIGCONT
  - SIGEMT
  - SIGFPE
  - SIGFREEZE
  - SIGHUP
  - SIGILL
  - SIGINFO
  - SIGINT
  - SIGIOSIGIOT
  - SIGKILL
  - SIGLOST
  - SIGLWP
  - SIGPIPE
  - SIGPWR
  - SIGQUIT ctrl+\  中断进程，并且产生core文件
  - SIGSEGV 指示进程进行了一次无效的内存引用
  - SIGSTOP
  - SIGSYS
  - SIGTERM 由kill命令发送的系统默认终止信号
  - SIGTSTP 交互停止信号，Ctrl+Z, 终端驱动程序产生此信号
  - SIGTTIN
  - SIGTTOU
  - SIGURG
  - SIGUSR1
  - SIGUSR2
  - SIGWINCH
  - SIGXCPU
  - SIGXFSZ

  


### 10.3 函数signal

- Unix系统信号机制最简单的接口是signal函数，但是signal的语义与实现有关，所以最好使用sigaction函数代替signal函数

- void(*signal(int signo, void(*func)(int)))(int);　　成功，返回以前的信号处理配置，出错，返回SIG_ERR

  - signo是信号名
  - func的值是常量SIG_IGN SIG_DFL 或接到此信号后要调用的函数的地址
  - typedef void Sigfunc(int);
  - Sigfunc* signal(int, Sigfunc*);

- kill命令和kill函数只是将一个信号发送给一个进程或进程组

  - 用户定义的信号

  -  kill -USR1 8249   发送SIGUSR1
  - kill -USR2 8249  发送SIGUSR2
  - kill 8249  向进程发送SIGTERM

- 程序启动

  - 当执行一个程序时，所有信号的状态都是系统默认或忽略
  - exec函数将原先设置为要捕捉的信号都更改为默认动作

- 进程创建

  - 当一个进程调用fork时，其子进程继承父进程的信号处理方式，因为子进程复制了父进程的内存映像

### 10.4 不可靠的信号

- 信号可能会丢失，但进程可能不知道
- 进程对信号的控制能力很差

### 10.5 中断的系统调用

- 被中断的系统调用，返回出错，errno设置为EINTR
- 低速系统调用
  - 可能会使系统永远阻塞的一类系统调用
- 其他系统调用
- 对于read, write系统调用，POSIX标准处理为部分成功返回
- POSIX要求只有中断信号的SA_RESTART标志有效时，实现才重启系统调用

### 10.6 可重入函数

- 信号处理程序中调用的函数可能影响主程序中调用的函数

- 在信号处理程序中保证调用安全的函数，这些函数是可重入的并被称为是异步信号安全的，在信号处理操作期间，它会阻塞任何会引起不一致的信号发送
- 不可重入的
  - 使用静态数据结构
  - 调用malloc或free
  - 是标准I/O函数(很多以不可重入的方式使用全局数据结构)，例如信号处理程序中使用printf函数，可能中断主程序中的printf函数调用
- 由于每个线程只有一个errno变量，信号处理程序应当在调用前保存errno,在调用后恢复errno
- 例: 在主程序中调用getwnam,在信号处理程序中也调用getwnam, malloc和free调用两次，维护的数据结构出现了损坏，程序因产生SIGSEGV信号而终止
- 在信号处理程序中调用一个非可重入函数，其结果是不可预知的

### 10.7 SIGCLD语义

- System V的一个信号名

### 10.8 可靠信号术语和语义

- 在信号产生和递送之间的时间间隔内，称信号是未决的
- 进程可以选用阻塞信号递送
- 每个进程都有一个信号屏蔽字，它规定了当前要阻塞递送到该进程的信号集

### 10.9 函数kill和raise

- kill函数将信号发送给进程或进程组
- raise函数则允许进程向自身发送信号
- 系统进程集包括内核进程和init

### 10.10 函数alarm和pause

- 使用alarm函数可以设置一个定时器，在将来的某个时刻该定时器会超时，产生SIGALRM信号
- 每个进程只能有一个闹钟时间
- pause函数使调用进程挂起直至捕捉到一个信号
- 只有执行了一个信号处理程序并从其返回时，pause才返回
- alarm和pasue之间的竞争条件问题
- 如果SIGALRM中断了某个其他信号处理程序，则调用longjmp会提早终止该信号处理程序
- 除了用来实现sleep函数外，alarm函数常用于对可能阻塞的操作设置时间上限值
  - 注意：如果系统调用是自动重启动的，则当从SIGALRM信号处理程序返回时，read并不被中断
  - 使用longjmp实现，无需担心一个慢速的系统调用是否被中断
  - 可能会有与其他信号处理程序交互的问题
- 如果要对I/O操作设置时间限制，另一种选择是使用select或poll函数

  

